[{"anchor":"function-all","name":"all","type":"fn all(s: & str, it: fn&(char) -> bool) -> bool","self":"","desc":"Return true if a predicate matches all characters or if the string contains no characters","path":"core::str"},{"anchor":"function-all_between","name":"all_between","type":"fn all_between(s: & str, start: uint, end: uint, it: fn&(char) -> bool) ->\n   bool","self":"","desc":"Loop through a substring, char by char","path":"core::str"},{"anchor":"function-any","name":"any","type":"fn any(ss: & str, pred: fn&(char) -> bool) -> bool","self":"","desc":"Return true if a predicate matches any character (and false if it matches none or there are no characters)","path":"core::str"},{"anchor":"function-any_between","name":"any_between","type":"fn any_between(s: & str, start: uint, end: uint, it: fn&(char) -> bool) ->\n   bool","self":"","desc":"Loop through a substring, char by char","path":"core::str"},{"anchor":"function-append","name":"append","type":"fn append(lhs: ~str, rhs: & str) -> ~str","self":"","desc":"Concatenate two strings together","path":"core::str"},{"anchor":"function-as_buf","name":"as_buf","type":"fn as_buf<T>(s: & str, f: fn&(*u8, uint) -> T) -> T","self":"","desc":"Work with the byte buffer and length of a slice.","path":"core::str"},{"anchor":"function-as_bytes","name":"as_bytes","type":"fn as_bytes<T>(s: & const ~str, f: fn&(& ~[u8]) -> T) -> T","self":"","desc":"Work with the byte buffer of a string.","path":"core::str"},{"anchor":"function-as_bytes_slice","name":"as_bytes_slice","type":"fn as_bytes_slice(s: &a/str) -> &a/[u8]","self":"","desc":"Work with the byte buffer of a string as a byte slice.","path":"core::str"},{"anchor":"function-as_c_str","name":"as_c_str","type":"fn as_c_str<T>(s: & str, f: fn&(*libc::c_char) -> T) -> T","self":"","desc":"Work with the byte buffer of a string as a null-terminated C string.","path":"core::str"},{"anchor":"function-byte_slice","name":"byte_slice","type":"fn byte_slice<T>(s: & str, f: fn&(v: & [u8]) -> T) -> T","self":"","desc":"Work with the string as a byte slice, not including trailing null.","path":"core::str"},{"anchor":"function-bytes_each","name":"bytes_each","type":"fn bytes_each(ss: & str, it: fn&(u8) -> bool)","self":"","desc":"Iterate over the bytes in a string","path":"core::str"},{"anchor":"function-capacity","name":"capacity","type":"fn capacity(s: & const ~str) -> uint","self":"","desc":"Returns the number of single-byte characters the string can hold without reallocating","path":"core::str"},{"anchor":"function-char_at","name":"char_at","type":"fn char_at(s: & str, i: uint) -> char","self":"","desc":"Pluck a character out of a string","path":"core::str"},{"anchor":"function-char_len","name":"char_len","type":"fn char_len(s: & str) -> uint","self":"","desc":"Returns the number of characters that a string holds","path":"core::str"},{"anchor":"function-char_range_at","name":"char_range_at","type":"fn char_range_at(s: & str, i: uint) -> {ch: char, next: uint,}","self":"","desc":"Pluck a character out of a string and return the index of the next character.","path":"core::str"},{"anchor":"function-char_range_at_reverse","name":"char_range_at_reverse","type":"fn char_range_at_reverse(ss: & str, start: uint) -> {ch: char, prev: uint,}","self":"","desc":"Given a byte position and a str, return the previous char and its position","path":"core::str"},{"anchor":"function-chars","name":"chars","type":"fn chars(s: & str) -> ~[char]","self":"","desc":"Convert a string to a vector of characters","path":"core::str"},{"anchor":"function-chars_each","name":"chars_each","type":"fn chars_each(s: & str, it: fn&(char) -> bool)","self":"","desc":"Iterate over the characters in a string","path":"core::str"},{"anchor":"function-concat","name":"concat","type":"fn concat(v: & [~str]) -> ~str","self":"","desc":"Concatenate a vector of strings","path":"core::str"},{"anchor":"function-connect","name":"connect","type":"fn connect(v: & [~str], sep: & str) -> ~str","self":"","desc":"Concatenate a vector of strings, placing a given separator between each","path":"core::str"},{"anchor":"function-contains","name":"contains","type":"fn contains(haystack: &a/str, needle: &b/str) -> bool","self":"","desc":"Returns true if one string contains another","path":"core::str"},{"anchor":"function-contains_char","name":"contains_char","type":"fn contains_char(haystack: & str, needle: char) -> bool","self":"","desc":"Returns true if a string contains a char.","path":"core::str"},{"anchor":"function-count_bytes","name":"count_bytes","type":"fn count_bytes(s: &b/str, start: uint, n: uint) -> uint","self":"","desc":"Counts the number of bytes taken by the ","path":"core::str"},{"anchor":"function-count_chars","name":"count_chars","type":"fn count_chars(s: & str, start: uint, end: uint) -> uint","self":"","desc":"As char_len but for a slice of a string","path":"core::str"},{"anchor":"function-each","name":"each","type":"fn each(s: & str, it: fn&(u8) -> bool)","self":"","desc":"Iterate over the bytes in a string","path":"core::str"},{"anchor":"function-each_char","name":"each_char","type":"fn each_char(s: & str, it: fn&(char) -> bool)","self":"","desc":"Iterates over the chars in a string","path":"core::str"},{"anchor":"function-each_chari","name":"each_chari","type":"fn each_chari(s: & str, it: fn&(uint, char) -> bool)","self":"","desc":"Iterates over the chars in a string, with indices","path":"core::str"},{"anchor":"function-eachi","name":"eachi","type":"fn eachi(s: & str, it: fn&(uint, u8) -> bool)","self":"","desc":"Iterate over the bytes in a string, with indices","path":"core::str"},{"anchor":"function-ends_with","name":"ends_with","type":"fn ends_with(haystack: &a/str, needle: &b/str) -> bool","self":"","desc":"Returns true if one string ends with another","path":"core::str"},{"anchor":"function-escape_default","name":"escape_default","type":"fn escape_default(s: & str) -> ~str","self":"","desc":"Escape each char in ","path":"core::str"},{"anchor":"function-escape_unicode","name":"escape_unicode","type":"fn escape_unicode(s: & str) -> ~str","self":"","desc":"Escape each char in ","path":"core::str"},{"anchor":"function-find","name":"find","type":"fn find(s: & str, f: fn&(char) -> bool) -> Option<uint>","self":"","desc":"Returns the byte index of the first character that satisfies the given predicate","path":"core::str"},{"anchor":"function-find_between","name":"find_between","type":"fn find_between(s: & str, start: uint, end: uint, f: fn&(char) -> bool) ->\n   Option<uint>","self":"","desc":"Returns the byte index of the first character that satisfies the given predicate, within a given range","path":"core::str"},{"anchor":"function-find_char","name":"find_char","type":"fn find_char(s: & str, c: char) -> Option<uint>","self":"","desc":"Returns the byte index of the first matching character","path":"core::str"},{"anchor":"function-find_char_between","name":"find_char_between","type":"fn find_char_between(s: & str, c: char, start: uint, end: uint) ->\n   Option<uint>","self":"","desc":"Returns the byte index of the first matching character within a given range","path":"core::str"},{"anchor":"function-find_char_from","name":"find_char_from","type":"fn find_char_from(s: & str, c: char, start: uint) -> Option<uint>","self":"","desc":"Returns the byte index of the first matching character beginning from a given byte offset","path":"core::str"},{"anchor":"function-find_from","name":"find_from","type":"fn find_from(s: & str, start: uint, f: fn&(char) -> bool) -> Option<uint>","self":"","desc":"Returns the byte index of the first character that satisfies the given predicate, beginning from a given byte offset","path":"core::str"},{"anchor":"function-find_str","name":"find_str","type":"fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint>","self":"","desc":"Returns the byte index of the first matching substring","path":"core::str"},{"anchor":"function-find_str_between","name":"find_str_between","type":"fn find_str_between(haystack: &a/str, needle: &b/str, start: uint, end: uint)\n   -> Option<uint>","self":"","desc":"Returns the byte index of the first matching substring within a given range","path":"core::str"},{"anchor":"function-find_str_from","name":"find_str_from","type":"fn find_str_from(haystack: &a/str, needle: &b/str, start: uint) ->\n   Option<uint>","self":"","desc":"Returns the byte index of the first matching substring beginning from a given byte offset","path":"core::str"},{"anchor":"function-from_byte","name":"from_byte","type":"fn from_byte(b: u8) -> ~str","self":"","desc":"Convert a byte to a UTF-8 string","path":"core::str"},{"anchor":"function-from_bytes","name":"from_bytes","type":"fn from_bytes(vv: & [const u8]) -> ~str","self":"","desc":"Convert a vector of bytes to a UTF-8 string","path":"core::str"},{"anchor":"function-from_char","name":"from_char","type":"fn from_char(ch: char) -> ~str","self":"","desc":"Convert a char to a string","path":"core::str"},{"anchor":"function-from_chars","name":"from_chars","type":"fn from_chars(chs: & [char]) -> ~str","self":"","desc":"Convert a vector of chars to a string","path":"core::str"},{"anchor":"function-from_slice","name":"from_slice","type":"fn from_slice(s: & str) -> ~str","self":"","desc":"Copy a slice into a new unique str","path":"core::str"},{"anchor":"function-from_utf16","name":"from_utf16","type":"fn from_utf16(v: & [u16]) -> ~str","self":"","desc":"","path":"core::str"},{"anchor":"function-ge","name":"ge","type":"fn ge(a: & str, b: & str) -> bool","self":"","desc":"Bytewise greater than or equal","path":"core::str"},{"anchor":"function-gt","name":"gt","type":"fn gt(a: & str, b: & str) -> bool","self":"","desc":"Bytewise greater than","path":"core::str"},{"anchor":"function-is_alphanumeric","name":"is_alphanumeric","type":"fn is_alphanumeric(s: & str) -> bool","self":"","desc":"Returns true if the string contains only alphanumerics","path":"core::str"},{"anchor":"function-is_ascii","name":"is_ascii","type":"fn is_ascii(s: & str) -> bool","self":"","desc":"Determines if a string contains only ASCII characters","path":"core::str"},{"anchor":"function-is_char_boundary","name":"is_char_boundary","type":"fn is_char_boundary(s: & str, index: uint) -> bool","self":"","desc":"Returns false if the index points into the middle of a multi-byte character sequence.","path":"core::str"},{"anchor":"function-is_empty","name":"is_empty","type":"fn is_empty(s: & str) -> bool","self":"","desc":"Returns true if the string has length 0","path":"core::str"},{"anchor":"function-is_not_empty","name":"is_not_empty","type":"fn is_not_empty(s: & str) -> bool","self":"","desc":"Returns true if the string has length greater than 0","path":"core::str"},{"anchor":"function-is_utf16","name":"is_utf16","type":"fn is_utf16(v: & [u16]) -> bool","self":"","desc":"Determines if a vector of ","path":"core::str"},{"anchor":"function-is_utf8","name":"is_utf8","type":"fn is_utf8(v: & [const u8]) -> bool","self":"","desc":"Determines if a vector of bytes contains valid UTF-8","path":"core::str"},{"anchor":"function-is_whitespace","name":"is_whitespace","type":"fn is_whitespace(s: & str) -> bool","self":"","desc":"Returns true if the string contains only whitespace","path":"core::str"},{"anchor":"function-iter_between_matches","name":"iter_between_matches","type":"fn iter_between_matches(s: &a/str, sep: &b/str, f: fn&(uint, uint))","self":"","desc":"","path":"core::str"},{"anchor":"function-iter_matches","name":"iter_matches","type":"fn iter_matches(s: &a/str, sep: &b/str, f: fn&(uint, uint))","self":"","desc":"","path":"core::str"},{"anchor":"function-le","name":"le","type":"fn le(a: & str, b: & str) -> bool","self":"","desc":"Bytewise less than or equal","path":"core::str"},{"anchor":"function-len","name":"len","type":"fn len(s: & str) -> uint","self":"","desc":"Returns the string length/size in bytes not counting the null terminator","path":"core::str"},{"anchor":"function-lines","name":"lines","type":"fn lines(s: & str) -> ~[~str]","self":"","desc":"Splits a string into a vector of the substrings separated by LF ('\\n')","path":"core::str"},{"anchor":"function-lines_any","name":"lines_any","type":"fn lines_any(s: & str) -> ~[~str]","self":"","desc":"Splits a string into a vector of the substrings separated by LF ('\\n') and/or CR LF (\"\\r\\n\")","path":"core::str"},{"anchor":"function-lines_each","name":"lines_each","type":"fn lines_each(ss: & str, ff: fn&(v: & str) -> bool)","self":"","desc":"Apply a function to each line (by '\\n')","path":"core::str"},{"anchor":"function-lt","name":"lt","type":"fn lt(a: & str, b: & str) -> bool","self":"","desc":"Bytewise slice less than","path":"core::str"},{"anchor":"function-map","name":"map","type":"fn map(ss: & str, ff: fn&(char) -> char) -> ~str","self":"","desc":"Apply a function to each character","path":"core::str"},{"anchor":"function-match_at","name":"match_at","type":"fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool","self":"","desc":"","path":"core::str"},{"anchor":"function-pop_char","name":"pop_char","type":"fn pop_char(s: & const ~str) -> char","self":"","desc":"Remove the final character from a string and return it","path":"core::str"},{"anchor":"function-push_char","name":"push_char","type":"fn push_char(s: & const ~str, ch: char)","self":"","desc":"Appends a character at the end of a string","path":"core::str"},{"anchor":"function-push_str","name":"push_str","type":"fn push_str(lhs: & const ~str, rhs: & str)","self":"","desc":"Appends a string slice to the back of a string","path":"core::str"},{"anchor":"function-push_str_no_overallocate","name":"push_str_no_overallocate","type":"fn push_str_no_overallocate(lhs: & const ~str, rhs: & str)","self":"","desc":"Appends a string slice to the back of a string, without overallocating","path":"core::str"},{"anchor":"function-replace","name":"replace","type":"fn replace(s: & str, from: & str, to: & str) -> ~str","self":"","desc":"Replace all occurrences of one string with another","path":"core::str"},{"anchor":"function-reserve","name":"reserve","type":"fn reserve(s: & const ~str, n: uint)","self":"","desc":"Reserves capacity for exactly ","path":"core::str"},{"anchor":"function-reserve_at_least","name":"reserve_at_least","type":"fn reserve_at_least(s: & const ~str, n: uint)","self":"","desc":"Reserves capacity for at least ","path":"core::str"},{"anchor":"function-rfind","name":"rfind","type":"fn rfind(s: & str, f: fn&(char) -> bool) -> Option<uint>","self":"","desc":"Returns the byte index of the last character that satisfies the given predicate","path":"core::str"},{"anchor":"function-rfind_between","name":"rfind_between","type":"fn rfind_between(s: & str, start: uint, end: uint, f: fn&(char) -> bool) ->\n   Option<uint>","self":"","desc":"Returns the byte index of the last character that satisfies the given predicate, within a given range","path":"core::str"},{"anchor":"function-rfind_char","name":"rfind_char","type":"fn rfind_char(s: & str, c: char) -> Option<uint>","self":"","desc":"Returns the byte index of the last matching character","path":"core::str"},{"anchor":"function-rfind_char_between","name":"rfind_char_between","type":"fn rfind_char_between(s: & str, c: char, start: uint, end: uint) ->\n   Option<uint>","self":"","desc":"Returns the byte index of the last matching character within a given range","path":"core::str"},{"anchor":"function-rfind_char_from","name":"rfind_char_from","type":"fn rfind_char_from(s: & str, c: char, start: uint) -> Option<uint>","self":"","desc":"Returns the byte index of the last matching character beginning from a given byte offset","path":"core::str"},{"anchor":"function-rfind_from","name":"rfind_from","type":"fn rfind_from(s: & str, start: uint, f: fn&(char) -> bool) -> Option<uint>","self":"","desc":"Returns the byte index of the last character that satisfies the given predicate, beginning from a given byte offset","path":"core::str"},{"anchor":"function-shift_char","name":"shift_char","type":"fn shift_char(s: & mut ~str) -> char","self":"","desc":"Remove the first character from a string and return it","path":"core::str"},{"anchor":"function-slice","name":"slice","type":"fn slice(s: & str, begin: uint, end: uint) -> ~str","self":"","desc":"Returns a slice of the given string from the byte range [","path":"core::str"},{"anchor":"function-split","name":"split","type":"fn split(s: & str, sepfn: fn&(char) -> bool) -> ~[~str]","self":"","desc":"Splits a string into substrings using a character function","path":"core::str"},{"anchor":"function-split_char","name":"split_char","type":"fn split_char(s: & str, sep: char) -> ~[~str]","self":"","desc":"Splits a string into substrings at each occurrence of a given character","path":"core::str"},{"anchor":"function-split_char_each","name":"split_char_each","type":"fn split_char_each(ss: & str, cc: char, ff: fn&(v: & str) -> bool)","self":"","desc":"Apply a function to each substring after splitting by character","path":"core::str"},{"anchor":"function-split_char_inner","name":"split_char_inner","type":"fn split_char_inner(s: & str, sep: char, count: uint, allow_empty: bool) ->\n   ~[~str]","self":"","desc":"","path":"core::str"},{"anchor":"function-split_char_nonempty","name":"split_char_nonempty","type":"fn split_char_nonempty(s: & str, sep: char) -> ~[~str]","self":"","desc":"Like ","path":"core::str"},{"anchor":"function-split_inner","name":"split_inner","type":"fn split_inner(s: & str, sepfn: fn&(cc: char) -> bool, count: uint,\n               allow_empty: bool) -> ~[~str]","self":"","desc":"","path":"core::str"},{"anchor":"function-split_nonempty","name":"split_nonempty","type":"fn split_nonempty(s: & str, sepfn: fn&(char) -> bool) -> ~[~str]","self":"","desc":"Like ","path":"core::str"},{"anchor":"function-split_str","name":"split_str","type":"fn split_str(s: &a/str, sep: &b/str) -> ~[~str]","self":"","desc":"Splits a string into a vector of the substrings separated by a given string","path":"core::str"},{"anchor":"function-split_str_nonempty","name":"split_str_nonempty","type":"fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str]","self":"","desc":"","path":"core::str"},{"anchor":"function-splitn","name":"splitn","type":"fn splitn(s: & str, sepfn: fn&(char) -> bool, count: uint) -> ~[~str]","self":"","desc":"Splits a string into substrings using a character function, cutting at most ","path":"core::str"},{"anchor":"function-splitn_char","name":"splitn_char","type":"fn splitn_char(s: & str, sep: char, count: uint) -> ~[~str]","self":"","desc":"Splits a string into substrings at each occurrence of a given character up to 'count' times","path":"core::str"},{"anchor":"function-splitn_char_each","name":"splitn_char_each","type":"fn splitn_char_each(ss: & str, sep: char, count: uint,\n                    ff: fn&(v: & str) -> bool)","self":"","desc":"Apply a function to each substring after splitting by character, up to ","path":"core::str"},{"anchor":"function-starts_with","name":"starts_with","type":"fn starts_with(haystack: &a/str, needle: &b/str) -> bool","self":"","desc":"Returns true if one string starts with another","path":"core::str"},{"anchor":"function-substr","name":"substr","type":"fn substr(s: & str, begin: uint, n: uint) -> ~str","self":"","desc":"Take a substring of another.","path":"core::str"},{"anchor":"function-to_bytes","name":"to_bytes","type":"fn to_bytes(s: & str) -> ~[u8]","self":"","desc":"Converts a string to a vector of bytes","path":"core::str"},{"anchor":"function-to_lower","name":"to_lower","type":"fn to_lower(s: & str) -> ~str","self":"","desc":"Convert a string to lowercase. ASCII only","path":"core::str"},{"anchor":"function-to_upper","name":"to_upper","type":"fn to_upper(s: & str) -> ~str","self":"","desc":"Convert a string to uppercase. ASCII only","path":"core::str"},{"anchor":"function-to_utf16","name":"to_utf16","type":"fn to_utf16(s: & str) -> ~[u16]","self":"","desc":"Converts to a vector of ","path":"core::str"},{"anchor":"function-trim","name":"trim","type":"fn trim(s: & str) -> ~str","self":"","desc":"Returns a string with leading and trailing whitespace removed","path":"core::str"},{"anchor":"function-trim_chars","name":"trim_chars","type":"fn trim_chars(s: & str, chars_to_trim: & [char]) -> ~str","self":"","desc":"Returns a string with leading and trailing ","path":"core::str"},{"anchor":"function-trim_left","name":"trim_left","type":"fn trim_left(s: & str) -> ~str","self":"","desc":"Returns a string with leading whitespace removed","path":"core::str"},{"anchor":"function-trim_left_chars","name":"trim_left_chars","type":"fn trim_left_chars(s: & str, chars_to_trim: & [char]) -> ~str","self":"","desc":"Returns a string with leading ","path":"core::str"},{"anchor":"function-trim_right","name":"trim_right","type":"fn trim_right(s: & str) -> ~str","self":"","desc":"Returns a string with trailing whitespace removed","path":"core::str"},{"anchor":"function-trim_right_chars","name":"trim_right_chars","type":"fn trim_right_chars(s: & str, chars_to_trim: & [char]) -> ~str","self":"","desc":"Returns a string with trailing ","path":"core::str"},{"anchor":"function-unshift_char","name":"unshift_char","type":"fn unshift_char(s: & mut ~str, ch: char)","self":"","desc":"Prepend a char to a string","path":"core::str"},{"anchor":"function-utf16_chars","name":"utf16_chars","type":"fn utf16_chars(v: & [u16], f: fn&(char))","self":"","desc":"","path":"core::str"},{"anchor":"function-utf8_char_width","name":"utf8_char_width","type":"fn utf8_char_width(b: u8) -> uint","self":"","desc":"Given a first byte, determine how many bytes are in this UTF-8 character","path":"core::str"},{"anchor":"function-view","name":"view","type":"fn view(s: &a/str, begin: uint, end: uint) -> &a/str","self":"","desc":"Returns a view of the given string from the byte range [","path":"core::str"},{"anchor":"function-view_shift_char","name":"view_shift_char","type":"fn view_shift_char(s: &a/str) -> (char, &a/str)","self":"","desc":"Removes the first character from a string slice and returns it. This does not allocate a new string; instead, it mutates a slice to point one character beyond the character that was shifted.","path":"core::str"},{"anchor":"function-words","name":"words","type":"fn words(s: & str) -> ~[~str]","self":"","desc":"Splits a string into a vector of the substrings separated by whitespace","path":"core::str"},{"anchor":"function-words_each","name":"words_each","type":"fn words_each(ss: & str, ff: fn&(v: & str) -> bool)","self":"","desc":"Apply a function to each word","path":"core::str"},{"anchor":"function-all","name":"all","type":"fn all<T>(v: & [T], f: fn&(t: & T) -> bool) -> bool","self":"","desc":"Return true if a predicate matches all elements","path":"core::vec"},{"anchor":"function-all2","name":"all2","type":"fn all2<T, U>(v0: & [T], v1: & [U], f: fn&(t: & T, u: & U) -> bool) -> bool","self":"","desc":"Return true if a predicate matches all elements in both vectors.","path":"core::vec"},{"anchor":"function-alli","name":"alli","type":"fn alli<T>(v: & [T], f: fn&(uint, t: & T) -> bool) -> bool","self":"","desc":"Return true if a predicate matches all elements","path":"core::vec"},{"anchor":"function-any","name":"any","type":"fn any<T>(v: & [T], f: fn&(t: & T) -> bool) -> bool","self":"","desc":"Return true if a predicate matches any elements","path":"core::vec"},{"anchor":"function-any2","name":"any2","type":"fn any2<T, U>(v0: & [T], v1: & [U], f: fn&(a: & T, b: & U) -> bool) -> bool","self":"","desc":"Return true if a predicate matches any elements in both vectors.","path":"core::vec"},{"anchor":"function-append","name":"append","type":"fn append<T: Copy>(lhs: ~[T], rhs: & [const T]) -> ~[T]","self":"","desc":"","path":"core::vec"},{"anchor":"function-append_mut","name":"append_mut","type":"fn append_mut<T: Copy>(lhs: ~[mut T], rhs: & [const T]) -> ~[mut T]","self":"","desc":"","path":"core::vec"},{"anchor":"function-append_one","name":"append_one","type":"fn append_one<T>(lhs: ~[T], x: T) -> ~[T]","self":"","desc":"","path":"core::vec"},{"anchor":"function-as_const_buf","name":"as_const_buf","type":"fn as_const_buf<T, U>(s: & [const T], f: fn&(*const T, uint) -> U) -> U","self":"","desc":"Similar to ","path":"core::vec"},{"anchor":"function-as_imm_buf","name":"as_imm_buf","type":"fn as_imm_buf<T, U>(s: & [T], f: fn&(*T, uint) -> U) -> U","self":"","desc":"Work with the buffer of a vector.","path":"core::vec"},{"anchor":"function-as_mut_buf","name":"as_mut_buf","type":"fn as_mut_buf<T, U>(s: & [mut T], f: fn&(*mut T, uint) -> U) -> U","self":"","desc":"Similar to ","path":"core::vec"},{"anchor":"function-build","name":"build","type":"fn build<A>(builder: fn&(push: pure fn&(v: A))) -> ~[A]","self":"","desc":"Builds a vector by calling a provided function with an argument function that pushes an element to the back of a vector.","path":"core::vec"},{"anchor":"function-build_sized","name":"build_sized","type":"fn build_sized<A>(size: uint, builder: fn&(push: pure fn&(v: A))) -> ~[A]","self":"","desc":"Builds a vector by calling a provided function with an argument function that pushes an element to the back of a vector. This version takes an initial size for the vector.","path":"core::vec"},{"anchor":"function-build_sized_opt","name":"build_sized_opt","type":"fn build_sized_opt<A>(size: Option<uint>, builder: fn&(push: pure fn&(v: A)))\n   -> ~[A]","self":"","desc":"Builds a vector by calling a provided function with an argument function that pushes an element to the back of a vector. This version takes an initial size for the vector.","path":"core::vec"},{"anchor":"function-capacity","name":"capacity","type":"fn capacity<T>(v: & const ~[T]) -> uint","self":"","desc":"Returns the number of elements the vector can hold without reallocating","path":"core::vec"},{"anchor":"function-concat","name":"concat","type":"fn concat<T: Copy>(v: & [~[T]]) -> ~[T]","self":"","desc":"Concatenate a vector of vectors.","path":"core::vec"},{"anchor":"function-connect","name":"connect","type":"fn connect<T: Copy>(v: & [~[T]], sep: & T) -> ~[T]","self":"","desc":"Concatenate a vector of vectors, placing a given separator between each","path":"core::vec"},{"anchor":"function-const_view","name":"const_view","type":"fn const_view<T>(v: &r/[const T], start: uint, end: uint) -> &r/[const T]","self":"","desc":"Return a slice that points into another slice.","path":"core::vec"},{"anchor":"function-consume","name":"consume","type":"fn consume<T>(v: ~[T], f: fn&(uint, v: T))","self":"","desc":"","path":"core::vec"},{"anchor":"function-consume_mut","name":"consume_mut","type":"fn consume_mut<T>(v: ~[mut T], f: fn&(uint, v: T))","self":"","desc":"","path":"core::vec"},{"anchor":"function-contains","name":"contains","type":"fn contains<T: Eq>(v: & [T], x: & T) -> bool","self":"","desc":"Return true if a vector contains an element with the given value","path":"core::vec"},{"anchor":"function-count","name":"count","type":"fn count<T: Eq>(v: & [T], x: & T) -> uint","self":"","desc":"Returns the number of elements that are equal to a given value","path":"core::vec"},{"anchor":"function-dedup","name":"dedup","type":"fn dedup<T: Eq>(v: & mut ~[T])","self":"","desc":"Remove consecutive repeated elements from a vector; if the vector is sorted, this removes all duplicates.","path":"core::vec"},{"anchor":"function-each","name":"each","type":"fn each<T>(v: &r/[T], f: fn&(&r/T) -> bool)","self":"","desc":"Iterates over a vector, with option to break","path":"core::vec"},{"anchor":"function-each2","name":"each2","type":"fn each2<U, T>(v1: & [U], v2: & [T], f: fn&(u: & U, t: & T) -> bool)","self":"","desc":"Iterates over two vectors simultaneously","path":"core::vec"},{"anchor":"function-each_const","name":"each_const","type":"fn each_const<T>(v: & [const T], f: fn&(elem: & const T) -> bool)","self":"","desc":"Like ","path":"core::vec"},{"anchor":"function-each_mut","name":"each_mut","type":"fn each_mut<T>(v: & [mut T], f: fn&(elem: & mut T) -> bool)","self":"","desc":"Like ","path":"core::vec"},{"anchor":"function-each_permutation","name":"each_permutation","type":"fn each_permutation<T: Copy>(v: & [T], put: fn&(ts: & [T]) -> bool)","self":"","desc":"Iterate over all permutations of vector ","path":"core::vec"},{"anchor":"function-eachi","name":"eachi","type":"fn eachi<T>(v: &r/[T], f: fn&(uint, v: &r/T) -> bool)","self":"","desc":"Iterates over a vector's elements and indices","path":"core::vec"},{"anchor":"function-eq","name":"eq","type":"fn eq<T: Eq>(a: & [T], b: & [T]) -> bool","self":"","desc":"","path":"core::vec"},{"anchor":"function-filter","name":"filter","type":"fn filter<T: Copy>(v: & [T], f: fn&(t: & T) -> bool) -> ~[T]","self":"","desc":"Construct a new vector from the elements of a vector for which some predicate holds.","path":"core::vec"},{"anchor":"function-filter_map","name":"filter_map","type":"fn filter_map<T, U: Copy>(v: & [T], f: fn&(t: & T) -> Option<U>) -> ~[U]","self":"","desc":"Apply a function to each element of a vector and return the results","path":"core::vec"},{"anchor":"function-find","name":"find","type":"fn find<T: Copy>(v: & [T], f: fn&(t: & T) -> bool) -> Option<T>","self":"","desc":"Search for the first element that matches a given predicate","path":"core::vec"},{"anchor":"function-find_between","name":"find_between","type":"fn find_between<T: Copy>(v: & [T], start: uint, end: uint,\n                         f: fn&(t: & T) -> bool) -> Option<T>","self":"","desc":"Search for the first element that matches a given predicate within a range","path":"core::vec"},{"anchor":"function-flat_map","name":"flat_map","type":"fn flat_map<T, U>(v: & [T], f: fn&(t: & T) -> ~[U]) -> ~[U]","self":"","desc":"Apply a function to each element of a vector and return a concatenation of each result vector","path":"core::vec"},{"anchor":"function-foldl","name":"foldl","type":"fn foldl<T: Copy, U>(z: T, v: & [U], p: fn&(t: T, u: & U) -> T) -> T","self":"","desc":"Reduce a vector from left to right","path":"core::vec"},{"anchor":"function-foldr","name":"foldr","type":"fn foldr<T, U: Copy>(v: & [T], z: U, p: fn&(t: & T, u: U) -> U) -> U","self":"","desc":"Reduce a vector from right to left","path":"core::vec"},{"anchor":"function-from_elem","name":"from_elem","type":"fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T]","self":"","desc":"Creates and initializes an immutable vector.","path":"core::vec"},{"anchor":"function-from_mut","name":"from_mut","type":"fn from_mut<T>(v: ~[mut T]) -> ~[T]","self":"","desc":"Produces an immutable vector from a mut vector.","path":"core::vec"},{"anchor":"function-from_slice","name":"from_slice","type":"fn from_slice<T: Copy>(t: & [T]) -> ~[T]","self":"","desc":"Creates a new unique vector with the same contents as the slice","path":"core::vec"},{"anchor":"function-ge","name":"ge","type":"fn ge<T: Ord>(a: & [T], b: & [T]) -> bool","self":"","desc":"","path":"core::vec"},{"anchor":"function-grow","name":"grow","type":"fn grow<T: Copy>(v: & mut ~[T], n: uint, initval: & T)","self":"","desc":"Expands a vector in place, initializing the new elements to a given value","path":"core::vec"},{"anchor":"function-grow_fn","name":"grow_fn","type":"fn grow_fn<T>(v: & mut ~[T], n: uint, op: iter::InitOp<T>)","self":"","desc":"Expands a vector in place, initializing the new elements to the result of a function","path":"core::vec"},{"anchor":"function-grow_set","name":"grow_set","type":"fn grow_set<T: Copy>(v: & mut ~[T], index: uint, initval: & T, val: T)","self":"","desc":"Sets the value of a vector element at a given index, growing the vector as needed","path":"core::vec"},{"anchor":"function-gt","name":"gt","type":"fn gt<T: Ord>(a: & [T], b: & [T]) -> bool","self":"","desc":"","path":"core::vec"},{"anchor":"function-head","name":"head","type":"fn head<T: Copy>(v: & [const T]) -> T","self":"","desc":"Returns the first element of a vector","path":"core::vec"},{"anchor":"function-init","name":"init","type":"fn init<T: Copy>(v: & [const T]) -> ~[T]","self":"","desc":"Returns a vector containing all but the last element of a slice","path":"core::vec"},{"anchor":"function-is_empty","name":"is_empty","type":"fn is_empty<T>(v: & [const T]) -> bool","self":"","desc":"Returns true if a vector contains no elements","path":"core::vec"},{"anchor":"function-is_not_empty","name":"is_not_empty","type":"fn is_not_empty<T>(v: & [const T]) -> bool","self":"","desc":"Returns true if a vector contains some elements","path":"core::vec"},{"anchor":"function-last","name":"last","type":"fn last<T: Copy>(v: & [const T]) -> T","self":"","desc":"Returns the last element of the slice ","path":"core::vec"},{"anchor":"function-last_opt","name":"last_opt","type":"fn last_opt<T: Copy>(v: & [const T]) -> Option<T>","self":"","desc":"Returns ","path":"core::vec"},{"anchor":"function-le","name":"le","type":"fn le<T: Ord>(a: & [T], b: & [T]) -> bool","self":"","desc":"","path":"core::vec"},{"anchor":"function-len","name":"len","type":"fn len<T>(v: & [const T]) -> uint","self":"","desc":"Returns the length of a vector","path":"core::vec"},{"anchor":"function-lt","name":"lt","type":"fn lt<T: Ord>(a: & [T], b: & [T]) -> bool","self":"","desc":"","path":"core::vec"},{"anchor":"function-map","name":"map","type":"fn map<T, U>(v: & [T], f: fn&(t: & T) -> U) -> ~[U]","self":"","desc":"Apply a function to each element of a vector and return the results","path":"core::vec"},{"anchor":"function-map2","name":"map2","type":"fn map2<T: Copy, U: Copy,\n        V>(v0: & [T], v1: & [U], f: fn&(t: & T, v: & U) -> V) -> ~[V]","self":"","desc":"Apply a function to each pair of elements and return the results","path":"core::vec"},{"anchor":"function-map_consume","name":"map_consume","type":"fn map_consume<T, U>(v: ~[T], f: fn&(v: T) -> U) -> ~[U]","self":"","desc":"","path":"core::vec"},{"anchor":"function-mapi","name":"mapi","type":"fn mapi<T, U>(v: & [T], f: fn&(uint, t: & T) -> U) -> ~[U]","self":"","desc":"Apply a function to each element of a vector and return the results","path":"core::vec"},{"anchor":"function-mut_view","name":"mut_view","type":"fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T]","self":"","desc":"Return a slice that points into another slice.","path":"core::vec"},{"anchor":"function-pop","name":"pop","type":"fn pop<T>(v: & mut ~[T]) -> T","self":"","desc":"Remove the last element from a vector and return it","path":"core::vec"},{"anchor":"function-position","name":"position","type":"fn position<T>(v: & [T], f: fn&(t: & T) -> bool) -> Option<uint>","self":"","desc":"Find the first index matching some predicate","path":"core::vec"},{"anchor":"function-position_between","name":"position_between","type":"fn position_between<T>(v: & [T], start: uint, end: uint,\n                       f: fn&(t: & T) -> bool) -> Option<uint>","self":"","desc":"Find the first index matching some predicate within a range","path":"core::vec"},{"anchor":"function-position_elem","name":"position_elem","type":"fn position_elem<T: Eq>(v: & [T], x: & T) -> Option<uint>","self":"","desc":"Find the first index containing a matching value","path":"core::vec"},{"anchor":"function-push","name":"push","type":"fn push<T>(v: & mut ~[T], initval: T)","self":"","desc":"Append an element to a vector","path":"core::vec"},{"anchor":"function-push_all","name":"push_all","type":"fn push_all<T: Copy>(v: & mut ~[T], rhs: & [const T])","self":"","desc":"","path":"core::vec"},{"anchor":"function-push_all_move","name":"push_all_move","type":"fn push_all_move<T>(v: & mut ~[T], rhs: ~[T])","self":"","desc":"","path":"core::vec"},{"anchor":"function-push_slow","name":"push_slow","type":"fn push_slow<T>(v: & mut ~[T], initval: T)","self":"","desc":"","path":"core::vec"},{"anchor":"function-reserve","name":"reserve","type":"fn reserve<T>(v: & mut ~[T], n: uint)","self":"","desc":"Reserves capacity for exactly ","path":"core::vec"},{"anchor":"function-reserve_at_least","name":"reserve_at_least","type":"fn reserve_at_least<T>(v: & mut ~[T], n: uint)","self":"","desc":"Reserves capacity for at least ","path":"core::vec"},{"anchor":"function-rev_each","name":"rev_each","type":"fn rev_each<T>(v: &r/[T], blk: fn&(v: &r/T) -> bool)","self":"","desc":"Iterates over a vector's elements in reverse","path":"core::vec"},{"anchor":"function-rev_eachi","name":"rev_eachi","type":"fn rev_eachi<T>(v: &r/[T], blk: fn&(i: uint, v: &r/T) -> bool)","self":"","desc":"Iterates over a vector's elements and indices in reverse","path":"core::vec"},{"anchor":"function-reverse","name":"reverse","type":"fn reverse<T>(v: & [mut T])","self":"","desc":"Reverse the order of elements in a vector, in place","path":"core::vec"},{"anchor":"function-reversed","name":"reversed","type":"fn reversed<T: Copy>(v: & [const T]) -> ~[T]","self":"","desc":"Returns a vector with the order of elements reversed","path":"core::vec"},{"anchor":"function-rfind","name":"rfind","type":"fn rfind<T: Copy>(v: & [T], f: fn&(t: & T) -> bool) -> Option<T>","self":"","desc":"Search for the last element that matches a given predicate","path":"core::vec"},{"anchor":"function-rfind_between","name":"rfind_between","type":"fn rfind_between<T: Copy>(v: & [T], start: uint, end: uint,\n                          f: fn&(t: & T) -> bool) -> Option<T>","self":"","desc":"Search for the last element that matches a given predicate within a range","path":"core::vec"},{"anchor":"function-rposition","name":"rposition","type":"fn rposition<T>(v: & [T], f: fn&(t: & T) -> bool) -> Option<uint>","self":"","desc":"Find the last index matching some predicate","path":"core::vec"},{"anchor":"function-rposition_between","name":"rposition_between","type":"fn rposition_between<T>(v: & [T], start: uint, end: uint,\n                        f: fn&(t: & T) -> bool) -> Option<uint>","self":"","desc":"Find the last index matching some predicate within a range","path":"core::vec"},{"anchor":"function-rposition_elem","name":"rposition_elem","type":"fn rposition_elem<T: Eq>(v: & [T], x: & T) -> Option<uint>","self":"","desc":"Find the last index containing a matching value","path":"core::vec"},{"anchor":"function-rsplit","name":"rsplit","type":"fn rsplit<T: Copy>(v: & [T], f: fn&(t: & T) -> bool) -> ~[~[T]]","self":"","desc":"Reverse split the vector ","path":"core::vec"},{"anchor":"function-rsplitn","name":"rsplitn","type":"fn rsplitn<T: Copy>(v: & [T], n: uint, f: fn&(t: & T) -> bool) -> ~[~[T]]","self":"","desc":"Reverse split the vector ","path":"core::vec"},{"anchor":"function-same_length","name":"same_length","type":"fn same_length<T, U>(xs: & [const T], ys: & [const U]) -> bool","self":"","desc":"Returns true if two vectors have the same length","path":"core::vec"},{"anchor":"function-shift","name":"shift","type":"fn shift<T>(v: & mut ~[T]) -> T","self":"","desc":"Removes the first element from a vector and return it","path":"core::vec"},{"anchor":"function-slice","name":"slice","type":"fn slice<T: Copy>(v: & [const T], start: uint, end: uint) -> ~[T]","self":"","desc":"Returns a copy of the elements from [","path":"core::vec"},{"anchor":"function-split","name":"split","type":"fn split<T: Copy>(v: & [T], f: fn&(t: & T) -> bool) -> ~[~[T]]","self":"","desc":"Split the vector ","path":"core::vec"},{"anchor":"function-splitn","name":"splitn","type":"fn splitn<T: Copy>(v: & [T], n: uint, f: fn&(t: & T) -> bool) -> ~[~[T]]","self":"","desc":"Split the vector ","path":"core::vec"},{"anchor":"function-swap","name":"swap","type":"fn swap<T>(v: & [mut T], a: uint, b: uint)","self":"","desc":"Swaps two elements in a vector","path":"core::vec"},{"anchor":"function-swap_remove","name":"swap_remove","type":"fn swap_remove<T>(v: & mut ~[T], index: uint) -> T","self":"","desc":"Remove an element from anywhere in the vector and return it, replacing it with the last element. This does not preserve ordering, but is O(1).","path":"core::vec"},{"anchor":"function-tail","name":"tail","type":"fn tail<T: Copy>(v: & [const T]) -> ~[T]","self":"","desc":"Returns a vector containing all but the first element of a slice","path":"core::vec"},{"anchor":"function-tailn","name":"tailn","type":"fn tailn<T: Copy>(v: & [const T], n: uint) -> ~[T]","self":"","desc":"Returns a vector containing all but the first ","path":"core::vec"},{"anchor":"function-to_mut","name":"to_mut","type":"fn to_mut<T>(v: ~[T]) -> ~[mut T]","self":"","desc":"Produces a mut vector from an immutable vector.","path":"core::vec"},{"anchor":"function-truncate","name":"truncate","type":"fn truncate<T>(v: & mut ~[T], newlen: uint)","self":"","desc":"Shorten a vector, dropping excess elements.","path":"core::vec"},{"anchor":"function-unshift","name":"unshift","type":"fn unshift<T>(v: & mut ~[T], x: T)","self":"","desc":"Prepend an element to the vector","path":"core::vec"},{"anchor":"function-unzip","name":"unzip","type":"fn unzip<T, U>(v: ~[(T, U)]) -> (~[T], ~[U])","self":"","desc":"Convert a vector of pairs into a pair of vectors.","path":"core::vec"},{"anchor":"function-unzip_slice","name":"unzip_slice","type":"fn unzip_slice<T: Copy, U: Copy>(v: & [(T, U)]) -> (~[T], ~[U])","self":"","desc":"Convert a vector of pairs into a pair of vectors, by reference. As unzip().","path":"core::vec"},{"anchor":"function-view","name":"view","type":"fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T]","self":"","desc":"Return a slice that points into another slice.","path":"core::vec"},{"anchor":"function-windowed","name":"windowed","type":"fn windowed<TT: Copy>(nn: uint, xx: & [TT]) -> ~[~[TT]]","self":"","desc":"","path":"core::vec"},{"anchor":"function-with_capacity","name":"with_capacity","type":"fn with_capacity<T>(capacity: uint) -> ~[T]","self":"","desc":"","path":"core::vec"},{"anchor":"function-zip","name":"zip","type":"fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)]","self":"","desc":"Convert two vectors to a vector of pairs.","path":"core::vec"},{"anchor":"function-zip_slice","name":"zip_slice","type":"fn zip_slice<T: Copy, U: Copy>(v: & [const T], u: & [const U]) -> ~[(T, U)]","self":"","desc":"Convert two vectors to a vector of pairs, by reference. As zip().","path":"core::vec"},{"anchor":"method-is_none","name":"is_none","type":"fn is_none() -> bool","self":"Option<T>","desc":"a method of Option<T>: Returns true if the option equals ","path":"core::option"},{"anchor":"method-is_some","name":"is_some","type":"fn is_some() -> bool","self":"Option<T>","desc":"a method of Option<T>: Returns true if the option contains some value","path":"core::option"},{"anchor":"method-chain_ref","name":"chain_ref","type":"fn chain_ref<U>(f: fn&(x: & T) -> Option<U>) -> Option<U>","self":"& Option<T>","desc":"a method of & Option<T>: Update an optional value by optionally running its content by reference through a function that returns an option.","path":"core::option"},{"anchor":"method-map_default","name":"map_default","type":"fn map_default<U>(def: U, f: fn&(x: & T) -> U) -> U","self":"& Option<T>","desc":"a method of & Option<T>: Applies a function to the contained value or returns a default","path":"core::option"},{"anchor":"method-iter","name":"iter","type":"fn iter(f: fn&(x: & T))","self":"& Option<T>","desc":"a method of & Option<T>: Performs an operation on the contained value by reference","path":"core::option"},{"anchor":"method-map","name":"map","type":"fn map<U>(f: fn&(x: & T) -> U) -> Option<U>","self":"& Option<T>","desc":"a method of & Option<T>: Maps a ","path":"core::option"},{"anchor":"method-get_ref","name":"get_ref","type":"fn get_ref() -> &self /T","self":"& Option<T>","desc":"a method of & Option<T>: Gets an immutable reference to the value inside an option.","path":"core::option"},{"anchor":"method-get","name":"get","type":"fn get() -> T","self":"Option<T>","desc":"a method of Option<T>: Gets the value out of an option","path":"core::option"},{"anchor":"method-get_default","name":"get_default","type":"fn get_default(def: T) -> T","self":"Option<T>","desc":"a method of Option<T>: ","path":"core::option"},{"anchor":"method-expect","name":"expect","type":"fn expect(reason: ~str) -> T","self":"Option<T>","desc":"a method of Option<T>: Gets the value out of an option, printing a specified message on failure","path":"core::option"},{"anchor":"method-while_some","name":"while_some","type":"fn while_some(blk: fn&(v: T) -> Option<T>)","self":"Option<T>","desc":"a method of Option<T>: Applies a function zero or more times until the result is none.","path":"core::option"},{"anchor":"function-chain","name":"chain","type":"fn chain<T, U>(opt: Option<T>, f: fn&(t: T) -> Option<U>) -> Option<U>","self":"","desc":"Update an optional value by optionally running its content through a function that returns an option.","path":"core::option"},{"anchor":"function-chain_ref","name":"chain_ref","type":"fn chain_ref<T, U>(opt: & Option<T>, f: fn&(x: & T) -> Option<U>) -> Option<U>","self":"","desc":"Update an optional value by optionally running its content by reference through a function that returns an option.","path":"core::option"},{"anchor":"function-expect","name":"expect","type":"fn expect<T: Copy>(opt: & Option<T>, reason: ~str) -> T","self":"","desc":"Gets the value out of an option, printing a specified message on failure","path":"core::option"},{"anchor":"function-get","name":"get","type":"fn get<T: Copy>(opt: & Option<T>) -> T","self":"","desc":"Gets the value out of an option","path":"core::option"},{"anchor":"function-get_default","name":"get_default","type":"fn get_default<T: Copy>(opt: & Option<T>, def: T) -> T","self":"","desc":"Returns the contained value or a default","path":"core::option"},{"anchor":"function-get_ref","name":"get_ref","type":"fn get_ref<T>(opt: &r/Option<T>) -> &r/T","self":"","desc":"Gets an immutable reference to the value inside an option.","path":"core::option"},{"anchor":"function-is_none","name":"is_none","type":"fn is_none<T>(opt: & Option<T>) -> bool","self":"","desc":"Returns true if the option equals ","path":"core::option"},{"anchor":"function-is_some","name":"is_some","type":"fn is_some<T>(opt: & Option<T>) -> bool","self":"","desc":"Returns true if the option contains some value","path":"core::option"},{"anchor":"function-iter","name":"iter","type":"fn iter<T>(opt: & Option<T>, f: fn&(x: & T))","self":"","desc":"Performs an operation on the contained value by reference","path":"core::option"},{"anchor":"function-map","name":"map","type":"fn map<T, U>(opt: & Option<T>, f: fn&(x: & T) -> U) -> Option<U>","self":"","desc":"Maps a ","path":"core::option"},{"anchor":"function-map_consume","name":"map_consume","type":"fn map_consume<T, U>(opt: Option<T>, f: fn&(v: T) -> U) -> Option<U>","self":"","desc":"As ","path":"core::option"},{"anchor":"function-map_default","name":"map_default","type":"fn map_default<T, U>(opt: & Option<T>, def: U, f: fn&(x: & T) -> U) -> U","self":"","desc":"Applies a function to the contained value or returns a default","path":"core::option"},{"anchor":"function-or","name":"or","type":"fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T>","self":"","desc":"Returns the leftmost some() value, or none if both are none.","path":"core::option"},{"anchor":"function-swap_unwrap","name":"swap_unwrap","type":"fn swap_unwrap<T>(opt: & mut Option<T>) -> T","self":"","desc":"The option dance. Moves a value out of an option type and returns it, replacing the original with ","path":"core::option"},{"anchor":"function-unwrap","name":"unwrap","type":"fn unwrap<T>(opt: Option<T>) -> T","self":"","desc":"Moves a value out of an option type and returns it.","path":"core::option"},{"anchor":"function-unwrap_expect","name":"unwrap_expect","type":"fn unwrap_expect<T>(opt: Option<T>, reason: & str) -> T","self":"","desc":"As unwrap, but with a specified failure message.","path":"core::option"},{"anchor":"function-while_some","name":"while_some","type":"fn while_some<T>(x: Option<T>, blk: fn&(v: T) -> Option<T>)","self":"","desc":"Applies a function zero or more times until the result is none.","path":"core::option"},{"anchor":"function-all_values","name":"all_values","type":"fn all_values(blk: fn&(v: bool))","self":"","desc":"Iterates over all truth values by passing them to ","path":"core::bool"},{"anchor":"function-and","name":"and","type":"fn and(a: bool, b: bool) -> bool","self":"","desc":"Conjunction","path":"core::bool"},{"anchor":"function-eq","name":"eq","type":"fn eq(a: bool, b: bool) -> bool","self":"","desc":"true if truth values ","path":"core::bool"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<bool>","self":"","desc":"Parse logic value from ","path":"core::bool"},{"anchor":"function-implies","name":"implies","type":"fn implies(a: bool, b: bool) -> bool","self":"","desc":"Implication in the logic, i.e. from ","path":"core::bool"},{"anchor":"function-is_false","name":"is_false","type":"fn is_false(v: bool) -> bool","self":"","desc":"true if ","path":"core::bool"},{"anchor":"function-is_true","name":"is_true","type":"fn is_true(v: bool) -> bool","self":"","desc":"true if ","path":"core::bool"},{"anchor":"function-ne","name":"ne","type":"fn ne(a: bool, b: bool) -> bool","self":"","desc":"true if truth values ","path":"core::bool"},{"anchor":"function-not","name":"not","type":"fn not(v: bool) -> bool","self":"","desc":"Negation / inverse","path":"core::bool"},{"anchor":"function-or","name":"or","type":"fn or(a: bool, b: bool) -> bool","self":"","desc":"Disjunction","path":"core::bool"},{"anchor":"function-to_bit","name":"to_bit","type":"fn to_bit(v: bool) -> u8","self":"","desc":"converts truth value to an 8 bit byte","path":"core::bool"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(v: bool) -> ~str","self":"","desc":"Convert ","path":"core::bool"},{"anchor":"function-xor","name":"xor","type":"fn xor(a: bool, b: bool) -> bool","self":"","desc":"Exclusive or","path":"core::bool"},{"anchor":"function-byteswriter","name":"BytesWriter","type":"fn BytesWriter() -> BytesWriter","self":"","desc":"","path":"core::io"},{"anchor":"function-fileres","name":"FILERes","type":"fn FILERes(f: *libc::FILE) -> FILERes","self":"","desc":"","path":"core::io"},{"anchor":"function-file_reader","name":"FILE_reader","type":"fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader","self":"","desc":"","path":"core::io"},{"anchor":"function-file_writer","name":"FILE_writer","type":"fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer","self":"","desc":"","path":"core::io"},{"anchor":"function-fdres","name":"FdRes","type":"fn FdRes(fd: fd_t) -> FdRes","self":"","desc":"","path":"core::io"},{"anchor":"function-buffered_file_writer","name":"buffered_file_writer","type":"fn buffered_file_writer(path: & Path) -> Result<Writer, ~str>","self":"","desc":"","path":"core::io"},{"anchor":"function-convert_whence","name":"convert_whence","type":"fn convert_whence(whence: SeekStyle) -> i32","self":"","desc":"","path":"core::io"},{"anchor":"function-fd_writer","name":"fd_writer","type":"fn fd_writer(fd: fd_t, cleanup: bool) -> Writer","self":"","desc":"","path":"core::io"},{"anchor":"function-file_reader-1","name":"file_reader","type":"fn file_reader(path: & Path) -> Result<Reader, ~str>","self":"","desc":"","path":"core::io"},{"anchor":"function-file_writer-1","name":"file_writer","type":"fn file_writer(path: & Path, flags: & [FileFlag]) -> Result<Writer, ~str>","self":"","desc":"","path":"core::io"},{"anchor":"function-mk_file_writer","name":"mk_file_writer","type":"fn mk_file_writer(path: & Path, flags: & [FileFlag]) -> Result<Writer, ~str>","self":"","desc":"","path":"core::io"},{"anchor":"function-print","name":"print","type":"fn print(s: & str)","self":"","desc":"","path":"core::io"},{"anchor":"function-println","name":"println","type":"fn println(s: & str)","self":"","desc":"","path":"core::io"},{"anchor":"function-read_whole_file","name":"read_whole_file","type":"fn read_whole_file(file: & Path) -> Result<~[u8], ~str>","self":"","desc":"","path":"core::io"},{"anchor":"function-read_whole_file_str","name":"read_whole_file_str","type":"fn read_whole_file_str(file: & Path) -> Result<~str, ~str>","self":"","desc":"","path":"core::io"},{"anchor":"function-seek_in_buf","name":"seek_in_buf","type":"fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) -> uint","self":"","desc":"","path":"core::io"},{"anchor":"function-stderr","name":"stderr","type":"fn stderr() -> Writer","self":"","desc":"","path":"core::io"},{"anchor":"function-stdin","name":"stdin","type":"fn stdin() -> Reader","self":"","desc":"","path":"core::io"},{"anchor":"function-stdout","name":"stdout","type":"fn stdout() -> Writer","self":"","desc":"","path":"core::io"},{"anchor":"function-u64_from_be_bytes","name":"u64_from_be_bytes","type":"fn u64_from_be_bytes(data: & [const u8], start: uint, size: uint) -> u64","self":"","desc":"","path":"core::io"},{"anchor":"function-u64_to_be_bytes","name":"u64_to_be_bytes","type":"fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn&(v: & [u8]) -> T) -> T","self":"","desc":"","path":"core::io"},{"anchor":"function-u64_to_le_bytes","name":"u64_to_le_bytes","type":"fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn&(v: & [u8]) -> T) -> T","self":"","desc":"","path":"core::io"},{"anchor":"function-with_bytes_reader","name":"with_bytes_reader","type":"fn with_bytes_reader<t>(bytes: & [u8], f: fn&(Reader) -> t) -> t","self":"","desc":"","path":"core::io"},{"anchor":"function-with_bytes_writer","name":"with_bytes_writer","type":"fn with_bytes_writer(f: fn&(Writer)) -> ~[u8]","self":"","desc":"","path":"core::io"},{"anchor":"function-with_str_reader","name":"with_str_reader","type":"fn with_str_reader<T>(s: & str, f: fn&(Reader) -> T) -> T","self":"","desc":"","path":"core::io"},{"anchor":"function-with_str_writer","name":"with_str_writer","type":"fn with_str_writer(f: fn&(Writer)) -> ~str","self":"","desc":"","path":"core::io"},{"anchor":"function-arch","name":"arch","type":"fn arch() -> ~str","self":"","desc":"","path":"core::os"},{"anchor":"function-args","name":"args","type":"fn args() -> ~[~str]","self":"","desc":"","path":"core::os"},{"anchor":"function-as_c_charp","name":"as_c_charp","type":"fn as_c_charp<T>(s: & str, f: fn&(*c_char) -> T) -> T","self":"","desc":"","path":"core::os"},{"anchor":"function-change_dir","name":"change_dir","type":"fn change_dir(p: & Path) -> bool","self":"","desc":"","path":"core::os"},{"anchor":"function-copy_file","name":"copy_file","type":"fn copy_file(from: & Path, to: & Path) -> bool","self":"","desc":"Copies a file from one location to another","path":"core::os"},{"anchor":"function-dll_filename","name":"dll_filename","type":"fn dll_filename(base: & str) -> ~str","self":"","desc":"","path":"core::os"},{"anchor":"function-dup2","name":"dup2","type":"fn dup2(src: c_int, dst: c_int) -> c_int","self":"","desc":"","path":"core::os"},{"anchor":"function-env","name":"env","type":"fn env() -> ~[(~str, ~str)]","self":"","desc":"","path":"core::os"},{"anchor":"function-family","name":"family","type":"fn family() -> ~str","self":"","desc":"","path":"core::os"},{"anchor":"function-fdopen","name":"fdopen","type":"fn fdopen(fd: c_int) -> *FILE","self":"","desc":"","path":"core::os"},{"anchor":"function-fill_charp_buf","name":"fill_charp_buf","type":"fn fill_charp_buf(f: fn&(*mut c_char, size_t) -> bool) -> Option<~str>","self":"","desc":"","path":"core::os"},{"anchor":"function-fsync_fd","name":"fsync_fd","type":"fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int","self":"","desc":"","path":"core::os"},{"anchor":"function-getcwd","name":"getcwd","type":"fn getcwd() -> Path","self":"","desc":"","path":"core::os"},{"anchor":"function-getenv","name":"getenv","type":"fn getenv(n: & str) -> Option<~str>","self":"","desc":"","path":"core::os"},{"anchor":"function-homedir","name":"homedir","type":"fn homedir() -> Option<Path>","self":"","desc":"Returns the path to the user's home directory, if known.","path":"core::os"},{"anchor":"function-last_os_error","name":"last_os_error","type":"fn last_os_error() -> ~str","self":"","desc":"Get a string representing the platform-dependent last error","path":"core::os"},{"anchor":"function-list_dir","name":"list_dir","type":"fn list_dir(p: & Path) -> ~[~str]","self":"","desc":"Lists the contents of a directory","path":"core::os"},{"anchor":"function-list_dir_path","name":"list_dir_path","type":"fn list_dir_path(p: & Path) -> ~[~Path]","self":"","desc":"Lists the contents of a directory","path":"core::os"},{"anchor":"function-load_argc_and_argv","name":"load_argc_and_argv","type":"fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str]","self":"","desc":"","path":"core::os"},{"anchor":"function-make_absolute","name":"make_absolute","type":"fn make_absolute(p: & Path) -> Path","self":"","desc":"Convert a relative path to an absolute path","path":"core::os"},{"anchor":"function-make_dir","name":"make_dir","type":"fn make_dir(p: & Path, mode: c_int) -> bool","self":"","desc":"Creates a directory at the specified path","path":"core::os"},{"anchor":"function-overridden_arg_key","name":"overridden_arg_key","type":"fn overridden_arg_key(_v: @OverriddenArgs)","self":"","desc":"","path":"core::os"},{"anchor":"function-path_exists","name":"path_exists","type":"fn path_exists(p: & Path) -> bool","self":"","desc":"Indicates whether a path exists","path":"core::os"},{"anchor":"function-path_is_dir","name":"path_is_dir","type":"fn path_is_dir(p: & Path) -> bool","self":"","desc":"Indicates whether a path represents a directory","path":"core::os"},{"anchor":"function-pipe","name":"pipe","type":"fn pipe() -> {in: c_int, out: c_int,}","self":"","desc":"","path":"core::os"},{"anchor":"function-real_args","name":"real_args","type":"fn real_args() -> ~[~str]","self":"","desc":"Returns the command line arguments","path":"core::os"},{"anchor":"function-remove_dir","name":"remove_dir","type":"fn remove_dir(p: & Path) -> bool","self":"","desc":"Removes a directory at the specified path","path":"core::os"},{"anchor":"function-remove_file","name":"remove_file","type":"fn remove_file(p: & Path) -> bool","self":"","desc":"Deletes an existing file","path":"core::os"},{"anchor":"function-self_exe_path","name":"self_exe_path","type":"fn self_exe_path() -> Option<Path>","self":"","desc":"","path":"core::os"},{"anchor":"function-set_args","name":"set_args","type":"fn set_args(new_args: ~[~str])","self":"","desc":"","path":"core::os"},{"anchor":"function-set_exit_status","name":"set_exit_status","type":"fn set_exit_status(code: int)","self":"","desc":"Sets the process exit code","path":"core::os"},{"anchor":"function-setenv","name":"setenv","type":"fn setenv(n: & str, v: & str)","self":"","desc":"","path":"core::os"},{"anchor":"function-tmpdir","name":"tmpdir","type":"fn tmpdir() -> Path","self":"","desc":"Returns the path to a temporary directory.","path":"core::os"},{"anchor":"function-waitpid","name":"waitpid","type":"fn waitpid(pid: pid_t) -> c_int","self":"","desc":"","path":"core::os"},{"anchor":"function-walk_dir","name":"walk_dir","type":"fn walk_dir(p: & Path, f: fn&(& Path) -> bool)","self":"","desc":"Recursively walk a directory structure","path":"core::os"},{"anchor":"function-path","name":"Path","type":"fn Path(s: & str) -> Path","self":"","desc":"","path":"core::path"},{"anchor":"function-normalize","name":"normalize","type":"fn normalize(components: & [~str]) -> ~[~str]","self":"","desc":"","path":"core::path"},{"anchor":"function-either","name":"either","type":"fn either<T, U,\n          V>(f_left: fn&(& T) -> V, f_right: fn&(& U) -> V,\n             value: & Either<T, U>) -> V","self":"","desc":"Applies a function based on the given either value","path":"core::either"},{"anchor":"function-flip","name":"flip","type":"fn flip<T: Copy, U: Copy>(eith: & Either<T, U>) -> Either<U, T>","self":"","desc":"Flips between left and right of a given either","path":"core::either"},{"anchor":"function-is_left","name":"is_left","type":"fn is_left<T, U>(eith: & Either<T, U>) -> bool","self":"","desc":"Checks whether the given value is a left","path":"core::either"},{"anchor":"function-is_right","name":"is_right","type":"fn is_right<T, U>(eith: & Either<T, U>) -> bool","self":"","desc":"Checks whether the given value is a right","path":"core::either"},{"anchor":"function-lefts","name":"lefts","type":"fn lefts<T: Copy, U>(eithers: & [Either<T, U>]) -> ~[T]","self":"","desc":"Extracts from a vector of either all the left values","path":"core::either"},{"anchor":"function-partition","name":"partition","type":"fn partition<T: Copy, U: Copy>(eithers: & [Either<T, U>]) ->\n   {lefts: ~[T], rights: ~[U],}","self":"","desc":"Extracts from a vector of either all the left values and right values","path":"core::either"},{"anchor":"function-rights","name":"rights","type":"fn rights<T, U: Copy>(eithers: & [Either<T, U>]) -> ~[U]","self":"","desc":"Extracts from a vector of either all the right values","path":"core::either"},{"anchor":"function-to_result","name":"to_result","type":"fn to_result<T: Copy, U: Copy>(eith: & Either<T, U>) -> Result<U, T>","self":"","desc":"Converts either::t to a result::t","path":"core::either"},{"anchor":"function-unwrap_left","name":"unwrap_left","type":"fn unwrap_left<T, U>(eith: Either<T, U>) -> T","self":"","desc":"Retrieves the value in the left branch. Fails if the either is Right.","path":"core::either"},{"anchor":"function-unwrap_right","name":"unwrap_right","type":"fn unwrap_right<T, U>(eith: Either<T, U>) -> U","self":"","desc":"Retrieves the value in the right branch. Fails if the either is Left.","path":"core::either"},{"anchor":"function-program_output","name":"program_output","type":"fn program_output(prog: & str, args: & [~str]) ->\n   {status: int, out: ~str, err: ~str,}","self":"","desc":"Spawns a process, waits for it to exit, and returns the exit code, and contents of stdout and stderr.","path":"core::run"},{"anchor":"function-read_all","name":"read_all","type":"fn read_all(rd: io::Reader) -> ~str","self":"","desc":"","path":"core::run"},{"anchor":"function-readclose","name":"readclose","type":"fn readclose(fd: c_int) -> ~str","self":"","desc":"","path":"core::run"},{"anchor":"function-run_program","name":"run_program","type":"fn run_program(prog: & str, args: & [~str]) -> int","self":"","desc":"Spawns a process and waits for it to terminate","path":"core::run"},{"anchor":"function-spawn_process","name":"spawn_process","type":"fn spawn_process(prog: & str, args: & [~str], env: & Option<~[(~str, ~str)]>,\n                 dir: & Option<~str>, in_fd: c_int, out_fd: c_int,\n                 err_fd: c_int) -> pid_t","self":"","desc":"Run a program, providing stdin, stdout and stderr handles","path":"core::run"},{"anchor":"function-start_program","name":"start_program","type":"fn start_program(prog: & str, args: & [~str]) -> Program","self":"","desc":"Spawns a process and returns a program","path":"core::run"},{"anchor":"function-waitpid","name":"waitpid","type":"fn waitpid(pid: pid_t) -> int","self":"","desc":"Waits for a process to exit and returns the exit code","path":"core::run"},{"anchor":"function-with_argv","name":"with_argv","type":"fn with_argv<T>(prog: & str, args: & [~str], cb: fn&(**libc::c_char) -> T) ->\n   T","self":"","desc":"","path":"core::run"},{"anchor":"function-with_dirp","name":"with_dirp","type":"fn with_dirp<T>(d: & Option<~str>, cb: fn&(*libc::c_char) -> T) -> T","self":"","desc":"","path":"core::run"},{"anchor":"function-with_envp","name":"with_envp","type":"fn with_envp<T>(env: & Option<~[(~str, ~str)]>, cb: fn&(*c_void) -> T) -> T","self":"","desc":"","path":"core::run"},{"anchor":"function-writeclose","name":"writeclose","type":"fn writeclose(fd: c_int, s: ~str)","self":"","desc":"","path":"core::run"},{"anchor":"function-append","name":"append","type":"fn append<T: Copy>(lhs: @[T], rhs: & [const T]) -> @[T]","self":"","desc":"","path":"core::at_vec"},{"anchor":"function-build","name":"build","type":"fn build<A>(builder: & fn&(push: pure fn&(v: A))) -> @[A]","self":"","desc":"Builds a vector by calling a provided function with an argument function that pushes an element to the back of a vector.","path":"core::at_vec"},{"anchor":"function-build_sized","name":"build_sized","type":"fn build_sized<A>(size: uint, builder: & fn&(push: pure fn&(v: A))) -> @[A]","self":"","desc":"Builds a vector by calling a provided function with an argument function that pushes an element to the back of a vector. This version takes an initial size for the vector.","path":"core::at_vec"},{"anchor":"function-build_sized_opt","name":"build_sized_opt","type":"fn build_sized_opt<A>(size: Option<uint>,\n                      builder: & fn&(push: pure fn&(v: A))) -> @[A]","self":"","desc":"Builds a vector by calling a provided function with an argument function that pushes an element to the back of a vector. This version takes an initial size for the vector.","path":"core::at_vec"},{"anchor":"function-capacity","name":"capacity","type":"fn capacity<T>(v: @[const T]) -> uint","self":"","desc":"Returns the number of elements the vector can hold without reallocating","path":"core::at_vec"},{"anchor":"function-from_elem","name":"from_elem","type":"fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T]","self":"","desc":"Creates and initializes an immutable vector.","path":"core::at_vec"},{"anchor":"function-from_fn","name":"from_fn","type":"fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T]","self":"","desc":"Creates and initializes an immutable vector.","path":"core::at_vec"},{"anchor":"function-map","name":"map","type":"fn map<T, U>(v: & [T], f: & fn&(x: & T) -> U) -> @[U]","self":"","desc":"Apply a function to each element of a vector and return the results","path":"core::at_vec"},{"anchor":"function-ptr_eq","name":"ptr_eq","type":"fn ptr_eq<T>(a: @T, b: @T) -> bool","self":"","desc":"Determine if two shared boxes point to the same object","path":"core::box"},{"anchor":"function-bump_box_refcount","name":"bump_box_refcount","type":"fn bump_box_refcount<T>(t: @T)","self":"","desc":"Force-increment the reference count on a shared box. If used carelessly, this can leak the box. Use this in conjunction with transmute and/or reinterpret_cast when such calls would otherwise scramble a box's reference count","path":"core::cast"},{"anchor":"function-copy_lifetime","name":"copy_lifetime","type":"fn copy_lifetime<S, T>(_ptr: &a/S, ptr: & T) -> &a/T","self":"","desc":"Transforms lifetime of the second pointer to match the first.","path":"core::cast"},{"anchor":"function-copy_lifetime_vec","name":"copy_lifetime_vec","type":"fn copy_lifetime_vec<S, T>(_ptr: &a/[S], ptr: & T) -> &a/T","self":"","desc":"Transforms lifetime of the second pointer to match the first.","path":"core::cast"},{"anchor":"function-forget","name":"forget","type":"fn forget<T>(thing: T)","self":"","desc":"Move a thing into the void","path":"core::cast"},{"anchor":"function-reinterpret_cast","name":"reinterpret_cast","type":"fn reinterpret_cast<T, U>(src: & T) -> U","self":"","desc":"Casts the value at ","path":"core::cast"},{"anchor":"function-transmute","name":"transmute","type":"fn transmute<L, G>(thing: L) -> G","self":"","desc":"Transform a value of one type into a value of another type. Both types must have the same size and alignment.","path":"core::cast"},{"anchor":"function-transmute_immut","name":"transmute_immut","type":"fn transmute_immut<T>(ptr: &a/mut T) -> &a/T","self":"","desc":"Coerce a mutable reference to be immutable.","path":"core::cast"},{"anchor":"function-transmute_immut_unsafe","name":"transmute_immut_unsafe","type":"fn transmute_immut_unsafe<T>(ptr: *const T) -> *T","self":"","desc":"Coerce an immutable reference to be mutable.","path":"core::cast"},{"anchor":"function-transmute_mut","name":"transmute_mut","type":"fn transmute_mut<T>(ptr: &a/T) -> &a/mut T","self":"","desc":"Coerce an immutable reference to be mutable.","path":"core::cast"},{"anchor":"function-transmute_mut_region","name":"transmute_mut_region","type":"fn transmute_mut_region<T>(ptr: &a/mut T) -> &b/mut T","self":"","desc":"Coerce a borrowed mutable pointer to have an arbitrary associated region.","path":"core::cast"},{"anchor":"function-transmute_mut_unsafe","name":"transmute_mut_unsafe","type":"fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T","self":"","desc":"Coerce an immutable reference to be mutable.","path":"core::cast"},{"anchor":"function-transmute_region","name":"transmute_region","type":"fn transmute_region<T>(ptr: &a/T) -> &b/T","self":"","desc":"Coerce a borrowed pointer to have an arbitrary associated region.","path":"core::cast"},{"anchor":"function-cmp","name":"cmp","type":"fn cmp(a: char, b: char) -> int","self":"","desc":"Compare two chars","path":"core::char"},{"anchor":"function-escape_default","name":"escape_default","type":"fn escape_default(c: char) -> ~str","self":"","desc":"Return a 'default' ASCII and C++11-like char-literal escape of a char.","path":"core::char"},{"anchor":"function-escape_unicode","name":"escape_unicode","type":"fn escape_unicode(c: char) -> ~str","self":"","desc":"Return the hexadecimal unicode escape of a char.","path":"core::char"},{"anchor":"function-is_alphanumeric","name":"is_alphanumeric","type":"fn is_alphanumeric(c: char) -> bool","self":"","desc":"Indicates whether a character is alphanumeric. Alphanumericness is defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.","path":"core::char"},{"anchor":"function-is_ascii","name":"is_ascii","type":"fn is_ascii(c: char) -> bool","self":"","desc":"Indicates whether the character is an ASCII character","path":"core::char"},{"anchor":"function-is_digit","name":"is_digit","type":"fn is_digit(c: char) -> bool","self":"","desc":"Indicates whether the character is numeric (Nd, Nl, or No)","path":"core::char"},{"anchor":"function-is_lowercase","name":"is_lowercase","type":"fn is_lowercase(c: char) -> bool","self":"","desc":"Indicates whether a character is in lower case, defined in terms of the Unicode General Category 'Ll'","path":"core::char"},{"anchor":"function-is_uppercase","name":"is_uppercase","type":"fn is_uppercase(c: char) -> bool","self":"","desc":"Indicates whether a character is in upper case, defined in terms of the Unicode General Category 'Lu'.","path":"core::char"},{"anchor":"function-is_whitespace","name":"is_whitespace","type":"fn is_whitespace(c: char) -> bool","self":"","desc":"Indicates whether a character is whitespace. Whitespace is defined in terms of the Unicode General Categories 'Zs', 'Zl', 'Zp' additional 'Cc'-category control codes in the range [0x09, 0x0d]","path":"core::char"},{"anchor":"function-to_digit","name":"to_digit","type":"fn to_digit(c: char, radix: uint) -> Option<uint>","self":"","desc":"Convert a char to the corresponding digit.","path":"core::char"},{"anchor":"function-eq","name":"eq","type":"fn eq<T: Eq>(v1: & T, v2: & T) -> bool","self":"","desc":"","path":"core::cmp"},{"anchor":"function-ge","name":"ge","type":"fn ge<T: Ord>(v1: & T, v2: & T) -> bool","self":"","desc":"","path":"core::cmp"},{"anchor":"function-gt","name":"gt","type":"fn gt<T: Ord>(v1: & T, v2: & T) -> bool","self":"","desc":"","path":"core::cmp"},{"anchor":"function-le","name":"le","type":"fn le<T: Ord Eq>(v1: & T, v2: & T) -> bool","self":"","desc":"","path":"core::cmp"},{"anchor":"function-lt","name":"lt","type":"fn lt<T: Ord>(v1: & T, v2: & T) -> bool","self":"","desc":"","path":"core::cmp"},{"anchor":"function-ne","name":"ne","type":"fn ne<T: Eq>(v1: & T, v2: & T) -> bool","self":"","desc":"","path":"core::cmp"},{"anchor":"method-chan","name":"chan","type":"fn chan() -> Chan<T>","self":"Port<T>","desc":"a method of Port<T>: ","path":"core::comm"},{"anchor":"method-send","name":"send","type":"fn send(v: T)","self":"Port<T>","desc":"a method of Port<T>: ","path":"core::comm"},{"anchor":"method-recv","name":"recv","type":"fn recv() -> T","self":"Port<T>","desc":"a method of Port<T>: ","path":"core::comm"},{"anchor":"method-peek","name":"peek","type":"fn peek() -> bool","self":"Port<T>","desc":"a method of Port<T>: ","path":"core::comm"},{"anchor":"method-chan-1","name":"chan","type":"fn chan() -> Chan<T>","self":"Chan<T>","desc":"a method of Chan<T>: ","path":"core::comm"},{"anchor":"method-send-1","name":"send","type":"fn send(v: T)","self":"Chan<T>","desc":"a method of Chan<T>: ","path":"core::comm"},{"anchor":"method-recv-1","name":"recv","type":"fn recv() -> T","self":"Chan<T>","desc":"a method of Chan<T>: ","path":"core::comm"},{"anchor":"method-peek-1","name":"peek","type":"fn peek() -> bool","self":"Chan<T>","desc":"a method of Chan<T>: ","path":"core::comm"},{"anchor":"function-chan","name":"Chan","type":"fn Chan<T: Send>(p: & Port<T>) -> Chan<T>","self":"","desc":"Constructs a channel. The channel is bound to the port used to construct it.","path":"core::comm"},{"anchor":"function-port","name":"Port","type":"fn Port<T: Send>() -> Port<T>","self":"","desc":"Constructs a port","path":"core::comm"},{"anchor":"function-portptr","name":"PortPtr","type":"fn PortPtr<T: Send>(po: *rust_port) -> PortPtr<T>","self":"","desc":"","path":"core::comm"},{"anchor":"function-as_raw_port","name":"as_raw_port","type":"fn as_raw_port<T: Send, U>(ch: comm::Chan<T>, f: fn&(*rust_port) -> U) -> U","self":"","desc":"Internal function for converting from a channel to a port","path":"core::comm"},{"anchor":"function-listen","name":"listen","type":"fn listen<T: Send, U>(f: fn&(Chan<T>) -> U) -> U","self":"","desc":"Open a new receiving channel for the duration of a function","path":"core::comm"},{"anchor":"function-peek","name":"peek","type":"fn peek<T: Send>(p: Port<T>) -> bool","self":"","desc":"Returns true if there are messages available","path":"core::comm"},{"anchor":"function-peek_","name":"peek_","type":"fn peek_(p: *rust_port) -> bool","self":"","desc":"","path":"core::comm"},{"anchor":"function-peek_chan","name":"peek_chan","type":"fn peek_chan<T: Send>(ch: comm::Chan<T>) -> bool","self":"","desc":"","path":"core::comm"},{"anchor":"function-recv","name":"recv","type":"fn recv<T: Send>(p: Port<T>) -> T","self":"","desc":"Receive from a port. If no data is available on the port then the task will block until data becomes available.","path":"core::comm"},{"anchor":"function-recv_","name":"recv_","type":"fn recv_<T: Send>(p: *rust_port) -> T","self":"","desc":"Receive on a raw port pointer","path":"core::comm"},{"anchor":"function-select2","name":"select2","type":"fn select2<A: Send, B: Send>(p_a: Port<A>, p_b: Port<B>) -> Either<A, B>","self":"","desc":"Receive on one of two ports","path":"core::comm"},{"anchor":"function-send","name":"send","type":"fn send<T: Send>(ch: Chan<T>, data: T)","self":"","desc":"Sends data over a channel. The sent data is moved into the channel, whereupon the caller loses access to it.","path":"core::comm"},{"anchor":"method-assert_links","name":"assert_links","type":"fn assert_links()","self":"DListNode<T>","desc":"a method of DListNode<T>: ","path":"core::dlist"},{"anchor":"method-next_link","name":"next_link","type":"fn next_link() -> Option<DListNode<T>>","self":"DListNode<T>","desc":"a method of DListNode<T>: Get the next node in the list, if there is one.","path":"core::dlist"},{"anchor":"method-next_node","name":"next_node","type":"fn next_node() -> DListNode<T>","self":"DListNode<T>","desc":"a method of DListNode<T>: Get the next node in the list, failing if there isn't one.","path":"core::dlist"},{"anchor":"method-prev_link","name":"prev_link","type":"fn prev_link() -> Option<DListNode<T>>","self":"DListNode<T>","desc":"a method of DListNode<T>: Get the previous node in the list, if there is one.","path":"core::dlist"},{"anchor":"method-prev_node","name":"prev_node","type":"fn prev_node() -> DListNode<T>","self":"DListNode<T>","desc":"a method of DListNode<T>: Get the previous node in the list, failing if there isn't one.","path":"core::dlist"},{"anchor":"method-new_link","name":"new_link","type":"fn new_link(data: T) -> DListLink<T>","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-assert_mine","name":"assert_mine","type":"fn assert_mine(nobe: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-make_mine","name":"make_mine","type":"fn make_mine(nobe: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-link","name":"link","type":"fn link(before: DListLink<T>, after: DListLink<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-unlink","name":"unlink","type":"fn unlink(nobe: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-add_head","name":"add_head","type":"fn add_head(nobe: DListLink<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-add_tail","name":"add_tail","type":"fn add_tail(nobe: DListLink<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-insert_left","name":"insert_left","type":"fn insert_left(nobe: DListLink<T>, neighbour: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-insert_right","name":"insert_right","type":"fn insert_right(neighbour: DListNode<T>, nobe: DListLink<T>)","self":"DList<T>","desc":"a method of DList<T>: ","path":"core::dlist"},{"anchor":"method-len","name":"len","type":"fn len() -> uint","self":"DList<T>","desc":"a method of DList<T>: Get the size of the list. O(1).","path":"core::dlist"},{"anchor":"method-is_empty","name":"is_empty","type":"fn is_empty() -> bool","self":"DList<T>","desc":"a method of DList<T>: Returns true if the list is empty. O(1).","path":"core::dlist"},{"anchor":"method-is_not_empty","name":"is_not_empty","type":"fn is_not_empty() -> bool","self":"DList<T>","desc":"a method of DList<T>: Returns true if the list is not empty. O(1).","path":"core::dlist"},{"anchor":"method-push_head","name":"push_head","type":"fn push_head(data: T)","self":"DList<T>","desc":"a method of DList<T>: Add data to the head of the list. O(1).","path":"core::dlist"},{"anchor":"method-push_head_n","name":"push_head_n","type":"fn push_head_n(data: T) -> DListNode<T>","self":"DList<T>","desc":"a method of DList<T>: Add data to the head of the list, and get the new containing node. O(1).","path":"core::dlist"},{"anchor":"method-push","name":"push","type":"fn push(data: T)","self":"DList<T>","desc":"a method of DList<T>: Add data to the tail of the list. O(1).","path":"core::dlist"},{"anchor":"method-push_n","name":"push_n","type":"fn push_n(data: T) -> DListNode<T>","self":"DList<T>","desc":"a method of DList<T>: Add data to the tail of the list, and get the new containing node. O(1).","path":"core::dlist"},{"anchor":"method-insert_before","name":"insert_before","type":"fn insert_before(data: T, neighbour: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: Insert data into the middle of the list, left of the given node. O(1).","path":"core::dlist"},{"anchor":"method-insert_n_before","name":"insert_n_before","type":"fn insert_n_before(nobe: DListNode<T>, neighbour: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: Insert an existing node in the middle of the list, left of the given node. O(1).","path":"core::dlist"},{"anchor":"method-insert_before_n","name":"insert_before_n","type":"fn insert_before_n(data: T, neighbour: DListNode<T>) -> DListNode<T>","self":"DList<T>","desc":"a method of DList<T>: Insert data in the middle of the list, left of the given node, and get its containing node. O(1).","path":"core::dlist"},{"anchor":"method-insert_after","name":"insert_after","type":"fn insert_after(data: T, neighbour: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: Insert data into the middle of the list, right of the given node. O(1).","path":"core::dlist"},{"anchor":"method-insert_n_after","name":"insert_n_after","type":"fn insert_n_after(nobe: DListNode<T>, neighbour: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: Insert an existing node in the middle of the list, right of the given node. O(1).","path":"core::dlist"},{"anchor":"method-insert_after_n","name":"insert_after_n","type":"fn insert_after_n(data: T, neighbour: DListNode<T>) -> DListNode<T>","self":"DList<T>","desc":"a method of DList<T>: Insert data in the middle of the list, right of the given node, and get its containing node. O(1).","path":"core::dlist"},{"anchor":"method-pop_n","name":"pop_n","type":"fn pop_n() -> Option<DListNode<T>>","self":"DList<T>","desc":"a method of DList<T>: Remove a node from the head of the list. O(1).","path":"core::dlist"},{"anchor":"method-pop_tail_n","name":"pop_tail_n","type":"fn pop_tail_n() -> Option<DListNode<T>>","self":"DList<T>","desc":"a method of DList<T>: Remove a node from the tail of the list. O(1).","path":"core::dlist"},{"anchor":"method-peek_n","name":"peek_n","type":"fn peek_n() -> Option<DListNode<T>>","self":"DList<T>","desc":"a method of DList<T>: Get the node at the list's head. O(1).","path":"core::dlist"},{"anchor":"method-peek_tail_n","name":"peek_tail_n","type":"fn peek_tail_n() -> Option<DListNode<T>>","self":"DList<T>","desc":"a method of DList<T>: Get the node at the list's tail. O(1).","path":"core::dlist"},{"anchor":"method-head_n","name":"head_n","type":"fn head_n() -> DListNode<T>","self":"DList<T>","desc":"a method of DList<T>: Get the node at the list's head, failing if empty. O(1).","path":"core::dlist"},{"anchor":"method-tail_n","name":"tail_n","type":"fn tail_n() -> DListNode<T>","self":"DList<T>","desc":"a method of DList<T>: Get the node at the list's tail, failing if empty. O(1).","path":"core::dlist"},{"anchor":"method-remove","name":"remove","type":"fn remove(nobe: DListNode<T>)","self":"DList<T>","desc":"a method of DList<T>: Remove a node from anywhere in the list. O(1).","path":"core::dlist"},{"anchor":"method-append","name":"append","type":"fn append(them: DList<T>)","self":"DList<T>","desc":"a method of DList<T>: Empty another list onto the end of this list, joining this list's tail to the other list's head. O(1).","path":"core::dlist"},{"anchor":"method-prepend","name":"prepend","type":"fn prepend(them: DList<T>)","self":"DList<T>","desc":"a method of DList<T>: Empty another list onto the start of this list, joining the other list's tail to this list's head. O(1).","path":"core::dlist"},{"anchor":"method-reverse","name":"reverse","type":"fn reverse()","self":"DList<T>","desc":"a method of DList<T>: Reverse the list's elements in place. O(n).","path":"core::dlist"},{"anchor":"method-clear","name":"clear","type":"fn clear()","self":"DList<T>","desc":"a method of DList<T>: Remove everything from the list. This is important because the cyclic links won't otherwise be automatically refcounted-collected. O(n).","path":"core::dlist"},{"anchor":"method-each_node","name":"each_node","type":"fn each_node(f: fn&(DListNode<T>) -> bool)","self":"DList<T>","desc":"a method of DList<T>: Iterate over nodes.","path":"core::dlist"},{"anchor":"method-assert_consistent","name":"assert_consistent","type":"fn assert_consistent()","self":"DList<T>","desc":"a method of DList<T>: Check data structure integrity. O(n).","path":"core::dlist"},{"anchor":"method-pop","name":"pop","type":"fn pop() -> Option<T>","self":"DList<T>","desc":"a method of DList<T>: Remove data from the head of the list. O(1).","path":"core::dlist"},{"anchor":"method-pop_tail","name":"pop_tail","type":"fn pop_tail() -> Option<T>","self":"DList<T>","desc":"a method of DList<T>: Remove data from the tail of the list. O(1).","path":"core::dlist"},{"anchor":"method-peek","name":"peek","type":"fn peek() -> Option<T>","self":"DList<T>","desc":"a method of DList<T>: Get data at the list's head. O(1).","path":"core::dlist"},{"anchor":"method-peek_tail","name":"peek_tail","type":"fn peek_tail() -> Option<T>","self":"DList<T>","desc":"a method of DList<T>: Get data at the list's tail. O(1).","path":"core::dlist"},{"anchor":"method-head","name":"head","type":"fn head() -> T","self":"DList<T>","desc":"a method of DList<T>: Get data at the list's head, failing if empty. O(1).","path":"core::dlist"},{"anchor":"method-tail","name":"tail","type":"fn tail() -> T","self":"DList<T>","desc":"a method of DList<T>: Get data at the list's tail, failing if empty. O(1).","path":"core::dlist"},{"anchor":"method-to_vec","name":"to_vec","type":"fn to_vec() -> ~[T]","self":"DList<T>","desc":"a method of DList<T>: Get the elements of the list as a vector. O(n).","path":"core::dlist"},{"anchor":"function-dlist","name":"DList","type":"fn DList<T>() -> DList<T>","self":"","desc":"Creates a new, empty dlist.","path":"core::dlist"},{"anchor":"function-concat","name":"concat","type":"fn concat<T>(lists: DList<DList<T>>) -> DList<T>","self":"","desc":"Produce a list from a list of lists, leaving no elements behind in the","path":"core::dlist"},{"anchor":"function-from_elem","name":"from_elem","type":"fn from_elem<T>(data: T) -> DList<T>","self":"","desc":"Creates a new dlist with a single element","path":"core::dlist"},{"anchor":"function-from_vec","name":"from_vec","type":"fn from_vec<T: Copy>(vec: & [T]) -> DList<T>","self":"","desc":"","path":"core::dlist"},{"anchor":"function-new_dlist_node","name":"new_dlist_node","type":"fn new_dlist_node<T>(data: T) -> DListNode<T>","self":"","desc":"Creates a new dlist node with the given data.","path":"core::dlist"},{"anchor":"method-check_not_borrowed","name":"check_not_borrowed","type":"fn check_not_borrowed()","self":"DVec<A>","desc":"a method of DVec<A>: ","path":"core::dvec"},{"anchor":"method-check_out","name":"check_out","type":"fn check_out<B>(f: & fn&(v: ~[A]) -> B) -> B","self":"DVec<A>","desc":"a method of DVec<A>: ","path":"core::dvec"},{"anchor":"method-give_back","name":"give_back","type":"fn give_back(data: ~[A])","self":"DVec<A>","desc":"a method of DVec<A>: ","path":"core::dvec"},{"anchor":"method-reserve","name":"reserve","type":"fn reserve(count: uint)","self":"DVec<A>","desc":"a method of DVec<A>: Reserves space for N elements","path":"core::dvec"},{"anchor":"method-swap","name":"swap","type":"fn swap(f: & fn&(v: ~[A]) -> ~[A])","self":"DVec<A>","desc":"a method of DVec<A>: Swaps out the current vector and hands it off to a user-provided function ","path":"core::dvec"},{"anchor":"method-swap_mut","name":"swap_mut","type":"fn swap_mut(f: & fn&(v: ~[mut A]) -> ~[mut A])","self":"DVec<A>","desc":"a method of DVec<A>: Swaps out the current vector and hands it off to a user-provided function ","path":"core::dvec"},{"anchor":"method-len","name":"len","type":"fn len() -> uint","self":"DVec<A>","desc":"a method of DVec<A>: Returns the number of elements currently in the dvec","path":"core::dvec"},{"anchor":"method-set","name":"set","type":"fn set(w: ~[A])","self":"DVec<A>","desc":"a method of DVec<A>: Overwrite the current contents","path":"core::dvec"},{"anchor":"method-pop","name":"pop","type":"fn pop() -> A","self":"DVec<A>","desc":"a method of DVec<A>: Remove and return the last element","path":"core::dvec"},{"anchor":"method-unshift","name":"unshift","type":"fn unshift(t: A)","self":"DVec<A>","desc":"a method of DVec<A>: Insert a single item at the front of the list","path":"core::dvec"},{"anchor":"method-push","name":"push","type":"fn push(t: A)","self":"DVec<A>","desc":"a method of DVec<A>: Append a single item to the end of the list","path":"core::dvec"},{"anchor":"method-shift","name":"shift","type":"fn shift() -> A","self":"DVec<A>","desc":"a method of DVec<A>: Remove and return the first element","path":"core::dvec"},{"anchor":"method-reverse","name":"reverse","type":"fn reverse()","self":"DVec<A>","desc":"a method of DVec<A>: Reverse the elements in the list, in place","path":"core::dvec"},{"anchor":"method-borrow","name":"borrow","type":"fn borrow<R>(op: fn&(x: & [A]) -> R) -> R","self":"DVec<A>","desc":"a method of DVec<A>: Gives access to the vector as a slice with immutable contents","path":"core::dvec"},{"anchor":"method-borrow_mut","name":"borrow_mut","type":"fn borrow_mut<R>(op: fn&(x: & [mut A]) -> R) -> R","self":"DVec<A>","desc":"a method of DVec<A>: Gives access to the vector as a slice with mutable contents","path":"core::dvec"},{"anchor":"method-push_all","name":"push_all","type":"fn push_all(ts: & [const A])","self":"DVec<A>","desc":"a method of DVec<A>: Append all elements of a vector to the end of the list","path":"core::dvec"},{"anchor":"method-push_slice","name":"push_slice","type":"fn push_slice(ts: & [const A], from_idx: uint, to_idx: uint)","self":"DVec<A>","desc":"a method of DVec<A>: Appends elements from ","path":"core::dvec"},{"anchor":"method-get","name":"get","type":"fn get() -> ~[A]","self":"DVec<A>","desc":"a method of DVec<A>: Append all elements of an iterable.","path":"core::dvec"},{"anchor":"method-get_elt","name":"get_elt","type":"fn get_elt(idx: uint) -> A","self":"DVec<A>","desc":"a method of DVec<A>: Copy out an individual element","path":"core::dvec"},{"anchor":"method-set_elt","name":"set_elt","type":"fn set_elt(idx: uint, a: A)","self":"DVec<A>","desc":"a method of DVec<A>: Overwrites the contents of the element at ","path":"core::dvec"},{"anchor":"method-grow_set_elt","name":"grow_set_elt","type":"fn grow_set_elt(idx: uint, initval: & A, val: A)","self":"DVec<A>","desc":"a method of DVec<A>: Overwrites the contents of the element at ","path":"core::dvec"},{"anchor":"method-last","name":"last","type":"fn last() -> A","self":"DVec<A>","desc":"a method of DVec<A>: Returns the last element, failing if the vector is empty","path":"core::dvec"},{"anchor":"method-rev_each","name":"rev_each","type":"fn rev_each(f: fn&(v: & A) -> bool)","self":"DVec<A>","desc":"a method of DVec<A>: Iterates over the elements in reverse order","path":"core::dvec"},{"anchor":"method-rev_eachi","name":"rev_eachi","type":"fn rev_eachi(f: fn&(uint, v: & A) -> bool)","self":"DVec<A>","desc":"a method of DVec<A>: Iterates over the elements and indices in reverse order","path":"core::dvec"},{"anchor":"function-dvec","name":"DVec","type":"fn DVec<A>() -> DVec<A>","self":"","desc":"Creates a new, empty dvec","path":"core::dvec"},{"anchor":"function-from_elem","name":"from_elem","type":"fn from_elem<A>(e: A) -> DVec<A>","self":"","desc":"Creates a new dvec with a single element","path":"core::dvec"},{"anchor":"function-from_vec","name":"from_vec","type":"fn from_vec<A>(v: ~[A]) -> DVec<A>","self":"","desc":"Creates a new dvec with the contents of a vector","path":"core::dvec"},{"anchor":"function-unwrap","name":"unwrap","type":"fn unwrap<A>(d: DVec<A>) -> ~[A]","self":"","desc":"Consumes the vector and returns its contents","path":"core::dvec"},{"anchor":"function-add","name":"add","type":"fn add(x: f32, y: f32) -> f32","self":"","desc":"","path":"core::f32"},{"anchor":"function-div","name":"div","type":"fn div(x: f32, y: f32) -> f32","self":"","desc":"","path":"core::f32"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: f32, y: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: f32, y: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: f32, y: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-is_nan","name":"is_NaN","type":"fn is_NaN(f: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-is_finite","name":"is_finite","type":"fn is_finite(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-is_infinite","name":"is_infinite","type":"fn is_infinite(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-is_zero","name":"is_zero","type":"fn is_zero(x: f32) -> bool","self":"","desc":"Returns true if ","path":"core::f32"},{"anchor":"function-le","name":"le","type":"fn le(x: f32, y: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-logarithm","name":"logarithm","type":"fn logarithm(n: f32, b: f32) -> f32","self":"","desc":"","path":"core::f32"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: f32, y: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: f32, y: f32) -> f32","self":"","desc":"","path":"core::f32"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: f32, y: f32) -> bool","self":"","desc":"","path":"core::f32"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: f32, y: f32) -> f32","self":"","desc":"","path":"core::f32"},{"anchor":"function-signbit","name":"signbit","type":"fn signbit(x: f32) -> int","self":"","desc":"","path":"core::f32"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: f32, y: f32) -> f32","self":"","desc":"","path":"core::f32"},{"anchor":"function-add","name":"add","type":"fn add(x: f64, y: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-div","name":"div","type":"fn div(x: f64, y: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: f64, y: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: f64, y: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: f64, y: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-is_nan","name":"is_NaN","type":"fn is_NaN(f: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-is_finite","name":"is_finite","type":"fn is_finite(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-is_infinite","name":"is_infinite","type":"fn is_infinite(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-is_zero","name":"is_zero","type":"fn is_zero(x: f64) -> bool","self":"","desc":"Returns true if ","path":"core::f64"},{"anchor":"function-le","name":"le","type":"fn le(x: f64, y: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-logarithm","name":"logarithm","type":"fn logarithm(n: f64, b: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: f64, y: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: f64, y: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: f64, y: f64) -> bool","self":"","desc":"","path":"core::f64"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: f64, y: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-signbit","name":"signbit","type":"fn signbit(x: f64) -> int","self":"","desc":"","path":"core::f64"},{"anchor":"function-sqrt","name":"sqrt","type":"fn sqrt(x: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: f64, y: f64) -> f64","self":"","desc":"","path":"core::f64"},{"anchor":"function-deflate_bytes","name":"deflate_bytes","type":"fn deflate_bytes(bytes: & [const u8]) -> ~[u8]","self":"","desc":"","path":"core::flate"},{"anchor":"function-inflate_bytes","name":"inflate_bytes","type":"fn inflate_bytes(bytes: & [const u8]) -> ~[u8]","self":"","desc":"","path":"core::flate"},{"anchor":"function-abs","name":"abs","type":"fn abs(x: float) -> float","self":"","desc":"","path":"core::float"},{"anchor":"function-atan","name":"atan","type":"fn atan(x: float) -> float","self":"","desc":"","path":"core::float"},{"anchor":"function-cos","name":"cos","type":"fn cos(x: float) -> float","self":"","desc":"","path":"core::float"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(num: & str) -> Option<float>","self":"","desc":"Convert a string to a float","path":"core::float"},{"anchor":"function-is_nan","name":"is_NaN","type":"fn is_NaN(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_finite","name":"is_finite","type":"fn is_finite(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_infinite","name":"is_infinite","type":"fn is_infinite(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-is_zero","name":"is_zero","type":"fn is_zero(x: float) -> bool","self":"","desc":"","path":"core::float"},{"anchor":"function-pow_with_uint","name":"pow_with_uint","type":"fn pow_with_uint(base: uint, pow: uint) -> float","self":"","desc":"Section: Arithmetics","path":"core::float"},{"anchor":"function-sin","name":"sin","type":"fn sin(x: float) -> float","self":"","desc":"","path":"core::float"},{"anchor":"function-sqrt","name":"sqrt","type":"fn sqrt(x: float) -> float","self":"","desc":"","path":"core::float"},{"anchor":"function-tan","name":"tan","type":"fn tan(x: float) -> float","self":"","desc":"","path":"core::float"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(num: float, digits: uint) -> ~str","self":"","desc":"Converts a float to a string with a maximum number of significant digits","path":"core::float"},{"anchor":"function-to_str_common","name":"to_str_common","type":"fn to_str_common(num: float, digits: uint, exact: bool) -> ~str","self":"","desc":"Section: String Conversions","path":"core::float"},{"anchor":"function-to_str_exact","name":"to_str_exact","type":"fn to_str_exact(num: float, digits: uint) -> ~str","self":"","desc":"Converts a float to a string with exactly the number of provided significant digits","path":"core::float"},{"anchor":"method-get","name":"get","type":"fn get() -> A","self":"Future<A>","desc":"a method of Future<A>: Get the value of the future","path":"core::future"},{"anchor":"method-get_ref","name":"get_ref","type":"fn get_ref() -> &self /A","self":"Future<A>","desc":"a method of Future<A>: ","path":"core::future"},{"anchor":"method-with","name":"with","type":"fn with<B>(blk: fn&(& A) -> B) -> B","self":"Future<A>","desc":"a method of Future<A>: Work with the value without copying it","path":"core::future"},{"anchor":"function-from_fn","name":"from_fn","type":"fn from_fn<A>(f: ~fn&() -> A) -> Future<A>","self":"","desc":"Create a future from a function.","path":"core::future"},{"anchor":"function-from_port","name":"from_port","type":"fn from_port<A: Send>(port: future_pipe::client::waiting<A>) -> Future<A>","self":"","desc":"Create a future from a port","path":"core::future"},{"anchor":"function-from_value","name":"from_value","type":"fn from_value<A>(val: A) -> Future<A>","self":"","desc":"Create a future from a value","path":"core::future"},{"anchor":"function-get","name":"get","type":"fn get<A: Copy>(future: & Future<A>) -> A","self":"","desc":"Get the value of the future","path":"core::future"},{"anchor":"function-get_ref","name":"get_ref","type":"fn get_ref<A>(future: &r/Future<A>) -> &r/A","self":"","desc":"Executes the future's closure and then returns a borrowed pointer to the result. The borrowed pointer lasts as long as the future.","path":"core::future"},{"anchor":"function-spawn","name":"spawn","type":"fn spawn<A: Send>(blk: fn~() -> A) -> Future<A>","self":"","desc":"Create a future from a unique closure.","path":"core::future"},{"anchor":"function-with","name":"with","type":"fn with<A, B>(future: & Future<A>, blk: fn&(& A) -> B) -> B","self":"","desc":"Work with the value without copying it","path":"core::future"},{"anchor":"function-rootset","name":"RootSet","type":"fn RootSet() -> RootSet","self":"","desc":"","path":"core::gc"},{"anchor":"function-align_to_pointer","name":"align_to_pointer","type":"fn align_to_pointer<T>(ptr: *T) -> *T","self":"","desc":"","path":"core::gc"},{"anchor":"function-bump","name":"bump","type":"fn bump<T, U>(ptr: *T, count: uint) -> *U","self":"","desc":"","path":"core::gc"},{"anchor":"function-cleanup_stack_for_failure","name":"cleanup_stack_for_failure","type":"fn cleanup_stack_for_failure()","self":"","desc":"","path":"core::gc"},{"anchor":"function-find_segment_for_frame","name":"find_segment_for_frame","type":"fn find_segment_for_frame(fp: *Word, segment: *StackSegment) ->\n   {segment: *StackSegment, boundary: bool,}","self":"","desc":"","path":"core::gc"},{"anchor":"function-gc","name":"gc","type":"fn gc()","self":"","desc":"","path":"core::gc"},{"anchor":"function-get_safe_point_count","name":"get_safe_point_count","type":"fn get_safe_point_count() -> uint","self":"","desc":"","path":"core::gc"},{"anchor":"function-is_frame_in_segment","name":"is_frame_in_segment","type":"fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool","self":"","desc":"","path":"core::gc"},{"anchor":"function-is_safe_point","name":"is_safe_point","type":"fn is_safe_point(pc: *Word) -> Option<SafePoint>","self":"","desc":"","path":"core::gc"},{"anchor":"function-walk_gc_roots","name":"walk_gc_roots","type":"fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor)","self":"","desc":"","path":"core::gc"},{"anchor":"function-walk_safe_point","name":"walk_safe_point","type":"fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor)","self":"","desc":"","path":"core::gc"},{"anchor":"function-sipstate","name":"SipState","type":"fn SipState(key0: u64, key1: u64) -> SipState","self":"","desc":"","path":"core::hash"},{"anchor":"function-state","name":"State","type":"fn State(k0: u64, k1: u64) -> State","self":"","desc":"","path":"core::hash"},{"anchor":"function-default_state","name":"default_state","type":"fn default_state() -> State","self":"","desc":"","path":"core::hash"},{"anchor":"function-hash_keyed_2","name":"hash_keyed_2","type":"fn hash_keyed_2<A: IterBytes, B: IterBytes>(a: & A, b: & B, k0: u64, k1: u64)\n   -> u64","self":"","desc":"","path":"core::hash"},{"anchor":"function-hash_keyed_3","name":"hash_keyed_3","type":"fn hash_keyed_3<A: IterBytes, B: IterBytes,\n                C: IterBytes>(a: & A, b: & B, c: & C, k0: u64, k1: u64) -> u64","self":"","desc":"","path":"core::hash"},{"anchor":"function-hash_keyed_4","name":"hash_keyed_4","type":"fn hash_keyed_4<A: IterBytes, B: IterBytes, C: IterBytes,\n                D: IterBytes>(a: & A, b: & B, c: & C, d: & D, k0: u64,\n                              k1: u64) -> u64","self":"","desc":"","path":"core::hash"},{"anchor":"function-hash_keyed_5","name":"hash_keyed_5","type":"fn hash_keyed_5<A: IterBytes, B: IterBytes, C: IterBytes, D: IterBytes,\n                E: IterBytes>(a: & A, b: & B, c: & C, d: & D, e: & E, k0: u64,\n                              k1: u64) -> u64","self":"","desc":"","path":"core::hash"},{"anchor":"function-abs","name":"abs","type":"fn abs(i: T) -> T","self":"","desc":"Computes the absolute value","path":"core::i16"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::i16"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::i16"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::i16"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::i16"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::i16"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::i16"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::i16"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(n: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::i16"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(n: T, radix: uint, f: fn&(v: & [u8]) -> U) -> U","self":"","desc":"","path":"core::i16"},{"anchor":"function-abs","name":"abs","type":"fn abs(i: T) -> T","self":"","desc":"Computes the absolute value","path":"core::i32"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::i32"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::i32"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::i32"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::i32"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::i32"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::i32"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::i32"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(n: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::i32"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(n: T, radix: uint, f: fn&(v: & [u8]) -> U) -> U","self":"","desc":"","path":"core::i32"},{"anchor":"function-abs","name":"abs","type":"fn abs(i: T) -> T","self":"","desc":"Computes the absolute value","path":"core::i64"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::i64"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::i64"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::i64"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::i64"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::i64"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::i64"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::i64"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(n: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::i64"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(n: T, radix: uint, f: fn&(v: & [u8]) -> U) -> U","self":"","desc":"","path":"core::i64"},{"anchor":"function-abs","name":"abs","type":"fn abs(i: T) -> T","self":"","desc":"Computes the absolute value","path":"core::i8"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::i8"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::i8"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::i8"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::i8"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::i8"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::i8"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::i8"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(n: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::i8"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(n: T, radix: uint, f: fn&(v: & [u8]) -> U) -> U","self":"","desc":"","path":"core::i8"},{"anchor":"function-abs","name":"abs","type":"fn abs(i: T) -> T","self":"","desc":"Computes the absolute value","path":"core::int"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::int"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::int"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::int"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::int"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::int"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::int"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::int"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(n: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::int"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(n: T, radix: uint, f: fn&(v: & [u8]) -> U) -> U","self":"","desc":"","path":"core::int"},{"anchor":"function-all","name":"all","type":"fn all<A, IA: BaseIter<A>>(self: & IA, blk: fn&(& A) -> bool) -> bool","self":"","desc":"","path":"core::iter"},{"anchor":"function-any","name":"any","type":"fn any<A, IA: BaseIter<A>>(self: & IA, blk: fn&(& A) -> bool) -> bool","self":"","desc":"","path":"core::iter"},{"anchor":"function-append","name":"append","type":"fn append<T: Copy, IT: BaseIter<T>, BT: Buildable<T>>(lhs: & IT, rhs: & IT) ->\n   BT","self":"","desc":"Appending two generic sequences","path":"core::iter"},{"anchor":"function-build","name":"build","type":"fn build<A, B: Buildable<A>>(builder: fn&(push: pure fn&(v: A))) -> B","self":"","desc":"Builds a sequence by calling a provided function with an argument function that pushes an element to the back of a sequence.","path":"core::iter"},{"anchor":"function-build_sized_opt","name":"build_sized_opt","type":"fn build_sized_opt<A,\n                   B: Buildable<A>>(size: Option<uint>,\n                                    builder: fn&(push: pure fn&(v: A))) -> B","self":"","desc":"Builds a sequence by calling a provided function with an argument function that pushes an element to the back of a sequence. This version takes an initial size for the sequence.","path":"core::iter"},{"anchor":"function-contains","name":"contains","type":"fn contains<A: Eq, IA: BaseIter<A>>(self: & IA, x: & A) -> bool","self":"","desc":"","path":"core::iter"},{"anchor":"function-copy_seq","name":"copy_seq","type":"fn copy_seq<T: Copy, IT: BaseIter<T>, BT: Buildable<T>>(v: & IT) -> BT","self":"","desc":"Copies a generic sequence, possibly converting it to a different","path":"core::iter"},{"anchor":"function-count","name":"count","type":"fn count<A: Eq, IA: BaseIter<A>>(self: & IA, x: & A) -> uint","self":"","desc":"","path":"core::iter"},{"anchor":"function-eachi","name":"eachi","type":"fn eachi<A, IA: BaseIter<A>>(self: & IA, blk: fn&(uint, v: & A) -> bool)","self":"","desc":"","path":"core::iter"},{"anchor":"function-filter_to_vec","name":"filter_to_vec","type":"fn filter_to_vec<A: Copy, IA: BaseIter<A>>(self: & IA, prd: fn&(a: A) -> bool)\n   -> ~[A]","self":"","desc":"","path":"core::iter"},{"anchor":"function-find","name":"find","type":"fn find<A: Copy, IA: BaseIter<A>>(self: & IA, p: fn&(a: A) -> bool) ->\n   Option<A>","self":"","desc":"","path":"core::iter"},{"anchor":"function-flat_map_to_vec","name":"flat_map_to_vec","type":"fn flat_map_to_vec<A: Copy, B: Copy, IA: BaseIter<A>,\n                   IB: BaseIter<B>>(self: & IA, op: fn&(a: A) -> IB) -> ~[B]","self":"","desc":"","path":"core::iter"},{"anchor":"function-foldl","name":"foldl","type":"fn foldl<A, B, IA: BaseIter<A>>(self: & IA, b0: B, blk: fn&(& B, & A) -> B) ->\n   B","self":"","desc":"","path":"core::iter"},{"anchor":"function-from_elem","name":"from_elem","type":"fn from_elem<T: Copy, BT: Buildable<T>>(n_elts: uint, t: T) -> BT","self":"","desc":"Creates and initializes a generic sequence with some element","path":"core::iter"},{"anchor":"function-from_fn","name":"from_fn","type":"fn from_fn<T, BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT","self":"","desc":"Creates and initializes a generic sequence from a function","path":"core::iter"},{"anchor":"function-map","name":"map","type":"fn map<T, IT: BaseIter<T>, U, BU: Buildable<U>>(v: & IT, f: fn&(& T) -> U) ->\n   BU","self":"","desc":"Apply a function to each element of an iterable and return the results","path":"core::iter"},{"anchor":"function-map_to_vec","name":"map_to_vec","type":"fn map_to_vec<A: Copy, B, IA: BaseIter<A>>(self: & IA, op: fn&(v: A) -> B) ->\n   ~[B]","self":"","desc":"","path":"core::iter"},{"anchor":"function-max","name":"max","type":"fn max<A: Copy Ord, IA: BaseIter<A>>(self: & IA) -> A","self":"","desc":"","path":"core::iter"},{"anchor":"function-min","name":"min","type":"fn min<A: Copy Ord, IA: BaseIter<A>>(self: & IA) -> A","self":"","desc":"","path":"core::iter"},{"anchor":"function-position","name":"position","type":"fn position<A, IA: BaseIter<A>>(self: & IA, f: fn&(& A) -> bool) ->\n   Option<uint>","self":"","desc":"","path":"core::iter"},{"anchor":"function-repeat","name":"repeat","type":"fn repeat(times: uint, blk: fn&() -> bool)","self":"","desc":"","path":"core::iter"},{"anchor":"function-to_vec","name":"to_vec","type":"fn to_vec<A: Copy, IA: BaseIter<A>>(self: & IA) -> ~[A]","self":"","desc":"","path":"core::iter"},{"anchor":"function-console_off","name":"console_off","type":"fn console_off()","self":"","desc":"Turns off logging to stdout globally","path":"core::logging"},{"anchor":"function-console_on","name":"console_on","type":"fn console_on()","self":"","desc":"Turns on logging to stdout globally","path":"core::logging"},{"anchor":"method-borrow_mut","name":"borrow_mut","type":"fn borrow_mut<R>(op: & fn&(t: & mut T) -> R) -> R","self":"Data<T>","desc":"a method of Data<T>: ","path":"core::mutable"},{"anchor":"method-borrow_const","name":"borrow_const","type":"fn borrow_const<R>(op: & fn&(t: & const T) -> R) -> R","self":"Data<T>","desc":"a method of Data<T>: ","path":"core::mutable"},{"anchor":"method-borrow_imm","name":"borrow_imm","type":"fn borrow_imm<R>(op: & fn&(t: & T) -> R) -> R","self":"Data<T>","desc":"a method of Data<T>: ","path":"core::mutable"},{"anchor":"function-mut","name":"Mut","type":"fn Mut<T>(t: T) -> Mut<T>","self":"","desc":"","path":"core::mutable"},{"anchor":"function-unwrap","name":"unwrap","type":"fn unwrap<T>(m: Mut<T>) -> T","self":"","desc":"","path":"core::mutable"},{"anchor":"method-mark_blocked","name":"mark_blocked","type":"fn mark_blocked(this: *rust_task) -> State","self":"PacketHeader","desc":"a method of PacketHeader: ","path":"core::pipes"},{"anchor":"method-unblock","name":"unblock","type":"fn unblock()","self":"PacketHeader","desc":"a method of PacketHeader: ","path":"core::pipes"},{"anchor":"method-buf_header","name":"buf_header","type":"fn buf_header() -> ~BufferHeader","self":"PacketHeader","desc":"a method of PacketHeader: ","path":"core::pipes"},{"anchor":"method-set_buffer","name":"set_buffer","type":"fn set_buffer<T: Send>(b: ~Buffer<T>)","self":"PacketHeader","desc":"a method of PacketHeader: ","path":"core::pipes"},{"anchor":"method-peek-1","name":"peek","type":"fn peek() -> bool","self":"RecvPacketBuffered<T, Tb>","desc":"a method of RecvPacketBuffered<T, Tb>: ","path":"core::pipes"},{"anchor":"method-unwrap","name":"unwrap","type":"fn unwrap() -> *Packet<T>","self":"SendPacketBuffered<T, Tbuffer>","desc":"a method of SendPacketBuffered<T, Tbuffer>: ","path":"core::pipes"},{"anchor":"method-header-1","name":"header","type":"fn header() -> *PacketHeader","self":"SendPacketBuffered<T, Tbuffer>","desc":"a method of SendPacketBuffered<T, Tbuffer>: ","path":"core::pipes"},{"anchor":"method-reuse_buffer","name":"reuse_buffer","type":"fn reuse_buffer() -> BufferResource<Tbuffer>","self":"SendPacketBuffered<T, Tbuffer>","desc":"a method of SendPacketBuffered<T, Tbuffer>: ","path":"core::pipes"},{"anchor":"function-bufferheader","name":"BufferHeader","type":"fn BufferHeader() -> BufferHeader","self":"","desc":"","path":"core::pipes"},{"anchor":"function-bufferresource","name":"BufferResource","type":"fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T>","self":"","desc":"","path":"core::pipes"},{"anchor":"function-packetheader","name":"PacketHeader","type":"fn PacketHeader() -> PacketHeader","self":"","desc":"","path":"core::pipes"},{"anchor":"function-portset","name":"PortSet","type":"fn PortSet<T: Send>() -> PortSet<T>","self":"","desc":"","path":"core::pipes"},{"anchor":"function-recvpacketbuffered","name":"RecvPacketBuffered","type":"fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>) ->\n   RecvPacketBuffered<T, Tbuffer>","self":"","desc":"","path":"core::pipes"},{"anchor":"function-sendpacketbuffered","name":"SendPacketBuffered","type":"fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>) ->\n   SendPacketBuffered<T, Tbuffer>","self":"","desc":"","path":"core::pipes"},{"anchor":"function-sharedchan","name":"SharedChan","type":"fn SharedChan<T: Send>(c: Chan<T>) -> SharedChan<T>","self":"","desc":"Converts a ","path":"core::pipes"},{"anchor":"function-oneshot","name":"oneshot","type":"fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>)","self":"","desc":"Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.","path":"core::pipes"},{"anchor":"function-peek","name":"peek","type":"fn peek<T: Send, Tb: Send>(p: & RecvPacketBuffered<T, Tb>) -> bool","self":"","desc":"Returns true if messages are available.","path":"core::pipes"},{"anchor":"function-recv","name":"recv","type":"fn recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>) -> T","self":"","desc":"Receives a message from a pipe.","path":"core::pipes"},{"anchor":"function-recv_one","name":"recv_one","type":"fn recv_one<T: Send>(port: PortOne<T>) -> T","self":"","desc":"Receive a message from a oneshot pipe, failing if the connection was closed.","path":"core::pipes"},{"anchor":"function-select","name":"select","type":"fn select<T: Send, Tb: Send>(endpoints: ~[RecvPacketBuffered<T, Tb>]) ->\n   (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])","self":"","desc":"Waits on a set of endpoints. Returns a message, its index, and a list of the remaining endpoints.","path":"core::pipes"},{"anchor":"function-select2","name":"select2","type":"fn select2<A: Send, Ab: Send, B: Send,\n           Bb: Send>(a: RecvPacketBuffered<A, Ab>,\n                     b: RecvPacketBuffered<B, Bb>) ->\n   Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n          (RecvPacketBuffered<A, Ab>, Option<B>)>","self":"","desc":"Receives a message from one of two endpoints.","path":"core::pipes"},{"anchor":"function-select2i","name":"select2i","type":"fn select2i<A: Selectable, B: Selectable>(a: & A, b: & B) -> Either<(), ()>","self":"","desc":"Returns 0 or 1 depending on which endpoint is ready to receive","path":"core::pipes"},{"anchor":"function-selecti","name":"selecti","type":"fn selecti<T: Selectable>(endpoints: & [T]) -> uint","self":"","desc":"Returns the index of an endpoint that is ready to receive.","path":"core::pipes"},{"anchor":"function-send_one","name":"send_one","type":"fn send_one<T: Send>(chan: ChanOne<T>, data: T)","self":"","desc":"Send a message on a oneshot pipe, failing if the connection was closed.","path":"core::pipes"},{"anchor":"function-spawn_service","name":"spawn_service","type":"fn spawn_service<T: Send,\n                 Tb: Send>(init:\n                               extern fn()\n                                   ->\n                                       (SendPacketBuffered<T, Tb>,\n                                        RecvPacketBuffered<T, Tb>),\n                           service: fn~(v: RecvPacketBuffered<T, Tb>)) ->\n   SendPacketBuffered<T, Tb>","self":"","desc":"Spawn a task to provide a service.","path":"core::pipes"},{"anchor":"function-spawn_service_recv","name":"spawn_service_recv","type":"fn spawn_service_recv<T: Send,\n                      Tb: Send>(init:\n                                    extern fn()\n                                        ->\n                                            (RecvPacketBuffered<T, Tb>,\n                                             SendPacketBuffered<T, Tb>),\n                                service: fn~(v: SendPacketBuffered<T, Tb>)) ->\n   RecvPacketBuffered<T, Tb>","self":"","desc":"Like ","path":"core::pipes"},{"anchor":"function-stream","name":"stream","type":"fn stream<T: Send>() -> (Chan<T>, Port<T>)","self":"","desc":"Creates a ","path":"core::pipes"},{"anchor":"function-try_recv","name":"try_recv","type":"fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>) ->\n   Option<T>","self":"","desc":"Attempts to receive a message from a pipe.","path":"core::pipes"},{"anchor":"function-try_recv_one","name":"try_recv_one","type":"fn try_recv_one<T: Send>(port: PortOne<T>) -> Option<T>","self":"","desc":"Receive a message from a oneshot pipe unless the connection was closed.","path":"core::pipes"},{"anchor":"function-try_send_one","name":"try_send_one","type":"fn try_send_one<T: Send>(chan: ChanOne<T>, data: T) -> bool","self":"","desc":"Send a message on a oneshot pipe, or return false if the connection was closed.","path":"core::pipes"},{"anchor":"function-wait_many","name":"wait_many","type":"fn wait_many<T: Selectable>(pkts: & [T]) -> uint","self":"","desc":"Returns when one of the packet headers reports data is available.","path":"core::pipes"},{"anchor":"function-addr_of","name":"addr_of","type":"fn addr_of<T>(val: & T) -> *T","self":"","desc":"Get an unsafe pointer to a value","path":"core::ptr"},{"anchor":"function-buf_len","name":"buf_len","type":"fn buf_len<T>(buf: **T) -> uint","self":"","desc":"Return the offset of the first null pointer in ","path":"core::ptr"},{"anchor":"function-const_offset","name":"const_offset","type":"fn const_offset<T>(ptr: *const T, count: uint) -> *const T","self":"","desc":"Calculate the offset from a const pointer","path":"core::ptr"},{"anchor":"function-is_not_null","name":"is_not_null","type":"fn is_not_null<T>(ptr: *const T) -> bool","self":"","desc":"Returns true if the pointer is not equal to the null pointer.","path":"core::ptr"},{"anchor":"function-is_null","name":"is_null","type":"fn is_null<T>(ptr: *const T) -> bool","self":"","desc":"Returns true if the pointer is equal to the null pointer.","path":"core::ptr"},{"anchor":"function-memcpy","name":"memcpy","type":"fn memcpy<T>(dst: *mut T, src: *const T, count: uint)","self":"","desc":"Copies data from one location to another","path":"core::ptr"},{"anchor":"function-memmove","name":"memmove","type":"fn memmove<T>(dst: *mut T, src: *const T, count: uint)","self":"","desc":"Copies data from one location to another","path":"core::ptr"},{"anchor":"function-memset","name":"memset","type":"fn memset<T>(dst: *mut T, c: int, count: uint)","self":"","desc":"","path":"core::ptr"},{"anchor":"function-mut_addr_of","name":"mut_addr_of","type":"fn mut_addr_of<T>(val: & T) -> *mut T","self":"","desc":"Get an unsafe mut pointer to a value","path":"core::ptr"},{"anchor":"function-mut_null","name":"mut_null","type":"fn mut_null<T>() -> *mut T","self":"","desc":"Create an unsafe mutable null pointer","path":"core::ptr"},{"anchor":"function-mut_offset","name":"mut_offset","type":"fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T","self":"","desc":"Calculate the offset from a mut pointer","path":"core::ptr"},{"anchor":"function-null","name":"null","type":"fn null<T>() -> *T","self":"","desc":"Create an unsafe null pointer","path":"core::ptr"},{"anchor":"function-offset","name":"offset","type":"fn offset<T>(ptr: *T, count: uint) -> *T","self":"","desc":"Calculate the offset from a pointer","path":"core::ptr"},{"anchor":"function-position","name":"position","type":"fn position<T>(buf: *T, f: fn&(& T) -> bool) -> uint","self":"","desc":"Return the first offset ","path":"core::ptr"},{"anchor":"function-ref_eq","name":"ref_eq","type":"fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool","self":"","desc":"Determine if two borrowed pointers point to the same thing.","path":"core::ptr"},{"anchor":"function-to_const_unsafe_ptr","name":"to_const_unsafe_ptr","type":"fn to_const_unsafe_ptr<T>(thing: & const T) -> *const T","self":"","desc":"Transform a const region pointer - &const T - to a const unsafe pointer - *const T. This is safe, but is implemented with an unsafe block due to reinterpret_cast.","path":"core::ptr"},{"anchor":"function-to_mut_unsafe_ptr","name":"to_mut_unsafe_ptr","type":"fn to_mut_unsafe_ptr<T>(thing: & mut T) -> *mut T","self":"","desc":"Transform a mutable region pointer - &mut T - to a mutable unsafe pointer - *mut T. This is safe, but is implemented with an unsafe block due to reinterpret_cast.","path":"core::ptr"},{"anchor":"function-to_uint","name":"to_uint","type":"fn to_uint<T>(thing: & T) -> uint","self":"","desc":"Cast a region pointer - &T - to a uint. This is safe, but is implemented with an unsafe block due to reinterpret_cast.","path":"core::ptr"},{"anchor":"function-to_unsafe_ptr","name":"to_unsafe_ptr","type":"fn to_unsafe_ptr<T>(thing: & T) -> *T","self":"","desc":"Transform a region pointer - &T - to an unsafe pointer - *T. This is safe, but is implemented with an unsafe block due to reinterpret_cast.","path":"core::ptr"},{"anchor":"method-gen_int","name":"gen_int","type":"fn gen_int() -> int","self":"Rng","desc":"a method of Rng: Return a random int","path":"core::rand"},{"anchor":"method-gen_int_range","name":"gen_int_range","type":"fn gen_int_range(start: int, end: int) -> int","self":"Rng","desc":"a method of Rng: Return an int randomly chosen from the range [start, end), failing if start >= end","path":"core::rand"},{"anchor":"method-gen_i8","name":"gen_i8","type":"fn gen_i8() -> i8","self":"Rng","desc":"a method of Rng: Return a random i8","path":"core::rand"},{"anchor":"method-gen_i16","name":"gen_i16","type":"fn gen_i16() -> i16","self":"Rng","desc":"a method of Rng: Return a random i16","path":"core::rand"},{"anchor":"method-gen_i32","name":"gen_i32","type":"fn gen_i32() -> i32","self":"Rng","desc":"a method of Rng: Return a random i32","path":"core::rand"},{"anchor":"method-gen_i64","name":"gen_i64","type":"fn gen_i64() -> i64","self":"Rng","desc":"a method of Rng: Return a random i64","path":"core::rand"},{"anchor":"method-gen_uint","name":"gen_uint","type":"fn gen_uint() -> uint","self":"Rng","desc":"a method of Rng: Return a random uint","path":"core::rand"},{"anchor":"method-gen_uint_range","name":"gen_uint_range","type":"fn gen_uint_range(start: uint, end: uint) -> uint","self":"Rng","desc":"a method of Rng: Return a uint randomly chosen from the range [start, end), failing if start >= end","path":"core::rand"},{"anchor":"method-gen_u8","name":"gen_u8","type":"fn gen_u8() -> u8","self":"Rng","desc":"a method of Rng: Return a random u8","path":"core::rand"},{"anchor":"method-gen_u16","name":"gen_u16","type":"fn gen_u16() -> u16","self":"Rng","desc":"a method of Rng: Return a random u16","path":"core::rand"},{"anchor":"method-gen_u32","name":"gen_u32","type":"fn gen_u32() -> u32","self":"Rng","desc":"a method of Rng: Return a random u32","path":"core::rand"},{"anchor":"method-gen_u64","name":"gen_u64","type":"fn gen_u64() -> u64","self":"Rng","desc":"a method of Rng: Return a random u64","path":"core::rand"},{"anchor":"method-gen_float","name":"gen_float","type":"fn gen_float() -> float","self":"Rng","desc":"a method of Rng: Return a random float in the interval [0,1]","path":"core::rand"},{"anchor":"method-gen_f32","name":"gen_f32","type":"fn gen_f32() -> f32","self":"Rng","desc":"a method of Rng: Return a random f32 in the interval [0,1]","path":"core::rand"},{"anchor":"method-gen_f64","name":"gen_f64","type":"fn gen_f64() -> f64","self":"Rng","desc":"a method of Rng: Return a random f64 in the interval [0,1]","path":"core::rand"},{"anchor":"method-gen_char","name":"gen_char","type":"fn gen_char() -> char","self":"Rng","desc":"a method of Rng: Return a random char","path":"core::rand"},{"anchor":"method-gen_char_from","name":"gen_char_from","type":"fn gen_char_from(chars: & str) -> char","self":"Rng","desc":"a method of Rng: Return a char randomly chosen from chars, failing if chars is empty","path":"core::rand"},{"anchor":"method-gen_bool","name":"gen_bool","type":"fn gen_bool() -> bool","self":"Rng","desc":"a method of Rng: Return a random bool","path":"core::rand"},{"anchor":"method-gen_weighted_bool","name":"gen_weighted_bool","type":"fn gen_weighted_bool(n: uint) -> bool","self":"Rng","desc":"a method of Rng: Return a bool with a 1 in n chance of true","path":"core::rand"},{"anchor":"method-gen_str","name":"gen_str","type":"fn gen_str(len: uint) -> ~str","self":"Rng","desc":"a method of Rng: Return a random string of the specified length composed of A-Z,a-z,0-9","path":"core::rand"},{"anchor":"method-gen_bytes","name":"gen_bytes","type":"fn gen_bytes(len: uint) -> ~[u8]","self":"Rng","desc":"a method of Rng: Return a random byte string of the specified length","path":"core::rand"},{"anchor":"method-choose","name":"choose","type":"fn choose<T: Copy>(values: & [T]) -> T","self":"Rng","desc":"a method of Rng: Choose an item randomly, failing if values is empty","path":"core::rand"},{"anchor":"method-choose_option","name":"choose_option","type":"fn choose_option<T: Copy>(values: & [T]) -> Option<T>","self":"Rng","desc":"a method of Rng: Choose Some(item) randomly, returning None if values is empty","path":"core::rand"},{"anchor":"method-choose_weighted","name":"choose_weighted","type":"fn choose_weighted<T: Copy>(v: & [Weighted<T>]) -> T","self":"Rng","desc":"a method of Rng: Choose an item respecting the relative weights, failing if the sum of the weights is 0","path":"core::rand"},{"anchor":"method-choose_weighted_option","name":"choose_weighted_option","type":"fn choose_weighted_option<T: Copy>(v: & [Weighted<T>]) -> Option<T>","self":"Rng","desc":"a method of Rng: Choose Some(item) respecting the relative weights, returning none if the sum of the weights is 0","path":"core::rand"},{"anchor":"method-weighted_vec","name":"weighted_vec","type":"fn weighted_vec<T: Copy>(v: & [Weighted<T>]) -> ~[T]","self":"Rng","desc":"a method of Rng: Return a vec containing copies of the items, in order, where the weight of the item determines how many copies there are","path":"core::rand"},{"anchor":"method-shuffle","name":"shuffle","type":"fn shuffle<T: Copy>(values: & [T]) -> ~[T]","self":"Rng","desc":"a method of Rng: Shuffle a vec","path":"core::rand"},{"anchor":"method-shuffle_mut","name":"shuffle_mut","type":"fn shuffle_mut<T>(values: & [mut T])","self":"Rng","desc":"a method of Rng: Shuffle a mutable vec in place","path":"core::rand"},{"anchor":"function-randres","name":"RandRes","type":"fn RandRes(c: *rctx) -> RandRes","self":"","desc":"","path":"core::rand"},{"anchor":"function-rng","name":"Rng","type":"fn Rng() -> Rng","self":"","desc":"Create a random number generator with a system specified seed","path":"core::rand"},{"anchor":"function-random","name":"random","type":"fn random() -> uint","self":"","desc":"Returns a random uint, using the task's based random number generator.","path":"core::rand"},{"anchor":"function-seed","name":"seed","type":"fn seed() -> ~[u8]","self":"","desc":"Create a new random seed for seeded_rng","path":"core::rand"},{"anchor":"function-seeded_rng","name":"seeded_rng","type":"fn seeded_rng(seed: & ~[u8]) -> Rng","self":"","desc":"Create a random number generator using the specified seed. A generator constructed with a given seed will generate the same sequence of values as all other generators constructed with the same seed. The seed may be any length.","path":"core::rand"},{"anchor":"function-seeded_xorshift","name":"seeded_xorshift","type":"fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng","self":"","desc":"","path":"core::rand"},{"anchor":"function-task_rng","name":"task_rng","type":"fn task_rng() -> Rng","self":"","desc":"Gives back a lazily initialized task-local random number generator, seeded by the system. Intended to be used in method chaining style, ie task_rng().gen_int().","path":"core::rand"},{"anchor":"function-tls_rng_state","name":"tls_rng_state","type":"fn tls_rng_state(_v: @RandRes)","self":"","desc":"","path":"core::rand"},{"anchor":"function-xorshift","name":"xorshift","type":"fn xorshift() -> Rng","self":"","desc":"","path":"core::rand"},{"anchor":"function-moveptradaptor","name":"MovePtrAdaptor","type":"fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V>","self":"","desc":"","path":"core::reflect"},{"anchor":"function-align","name":"align","type":"fn align(size: uint, align: uint) -> uint","self":"","desc":"Helper function for alignment calculation.","path":"core::reflect"},{"anchor":"method-get","name":"get","type":"fn get<T>(f: fn&(& T)) -> bool","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-visit_inner","name":"visit_inner","type":"fn visit_inner(inner: *TyDesc) -> bool","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-visit_ptr_inner","name":"visit_ptr_inner","type":"fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-write","name":"write","type":"fn write<T: Repr>() -> bool","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-write_escaped_slice","name":"write_escaped_slice","type":"fn write_escaped_slice(slice: & str)","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-write_mut_qualifier","name":"write_mut_qualifier","type":"fn write_mut_qualifier(mtbl: uint)","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-write_vec_range","name":"write_vec_range","type":"fn write_vec_range(mtbl: uint, ptr: *u8, len: uint, inner: *TyDesc) -> bool","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-write_unboxed_vec_repr","name":"write_unboxed_vec_repr","type":"fn write_unboxed_vec_repr(mtbl: uint, v: & UnboxedVecRepr, inner: *TyDesc) ->\n   bool","self":"ReprVisitor","desc":"a method of ReprVisitor: ","path":"core::repr"},{"anchor":"method-align","name":"align","type":"fn align(n: uint)","self":"ReprPrinter","desc":"a method of ReprPrinter: ","path":"core::repr"},{"anchor":"method-bump","name":"bump","type":"fn bump(n: uint)","self":"ReprPrinter","desc":"a method of ReprPrinter: ","path":"core::repr"},{"anchor":"method-log_simple","name":"log_simple","type":"fn log_simple<T: Repr>() -> bool","self":"ReprPrinter","desc":"a method of ReprPrinter: ","path":"core::repr"},{"anchor":"method-visit_estr","name":"visit_estr","type":"fn visit_estr() -> bool","self":"ReprPrinterWrapper","desc":"a method of ReprPrinterWrapper: ","path":"core::repr"},{"anchor":"method-visit_self_describing_heap_alloc","name":"visit_self_describing_heap_alloc","type":"fn visit_self_describing_heap_alloc(mtbl: uint) -> bool","self":"ReprPrinterWrapper","desc":"a method of ReprPrinterWrapper: ","path":"core::repr"},{"anchor":"method-visit_ptr_contents","name":"visit_ptr_contents","type":"fn visit_ptr_contents(mtbl: uint, inner: *TyDesc) -> bool","self":"ReprPrinterWrapper","desc":"a method of ReprPrinterWrapper: ","path":"core::repr"},{"anchor":"method-visit_evec","name":"visit_evec","type":"fn visit_evec(mtbl: uint, inner: *TyDesc) -> bool","self":"ReprPrinterWrapper","desc":"a method of ReprPrinterWrapper: ","path":"core::repr"},{"anchor":"function-reprvisitor","name":"ReprVisitor","type":"fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor","self":"","desc":"","path":"core::repr"},{"anchor":"function-align","name":"align","type":"fn align(size: uint, align: uint) -> uint","self":"","desc":"Helpers","path":"core::repr"},{"anchor":"function-write_repr","name":"write_repr","type":"fn write_repr<T>(writer: @Writer, object: & T)","self":"","desc":"","path":"core::repr"},{"anchor":"function-write_repr2","name":"write_repr2","type":"fn write_repr2<T>(writer: @Writer, object: & T)","self":"","desc":"","path":"core::repr"},{"anchor":"method-is_ok","name":"is_ok","type":"fn is_ok() -> bool","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-is_err","name":"is_err","type":"fn is_err() -> bool","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-iter","name":"iter","type":"fn iter(f: fn&(& T))","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-iter_err","name":"iter_err","type":"fn iter_err(f: fn&(& E))","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-get","name":"get","type":"fn get() -> T","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-map_err","name":"map_err","type":"fn map_err<F: Copy>(op: fn&(& E) -> F) -> Result<T, F>","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-get_err","name":"get_err","type":"fn get_err() -> E","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-map","name":"map","type":"fn map<U: Copy>(op: fn&(& T) -> U) -> Result<U, E>","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-chain","name":"chain","type":"fn chain<U: Copy>(op: fn&(t: T) -> Result<U, E>) -> Result<U, E>","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"method-chain_err","name":"chain_err","type":"fn chain_err<F: Copy>(op: fn&(t: E) -> Result<T, F>) -> Result<T, F>","self":"Result<T, E>","desc":"a method of Result<T, E>: ","path":"core::result"},{"anchor":"function-chain","name":"chain","type":"fn chain<T, U: Copy,\n         V: Copy>(res: Result<T, V>, op: fn&(t: T) -> Result<U, V>) ->\n   Result<U, V>","self":"","desc":"Call a function based on a previous result","path":"core::result"},{"anchor":"function-chain_err","name":"chain_err","type":"fn chain_err<T: Copy, U: Copy,\n             V: Copy>(res: Result<T, V>, op: fn&(t: V) -> Result<T, U>) ->\n   Result<T, U>","self":"","desc":"Call a function based on a previous result","path":"core::result"},{"anchor":"function-get","name":"get","type":"fn get<T: Copy, U>(res: & Result<T, U>) -> T","self":"","desc":"Get the value out of a successful result","path":"core::result"},{"anchor":"function-get_err","name":"get_err","type":"fn get_err<T, U: Copy>(res: & Result<T, U>) -> U","self":"","desc":"Get the value out of an error result","path":"core::result"},{"anchor":"function-get_ref","name":"get_ref","type":"fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T","self":"","desc":"Get a reference to the value out of a successful result","path":"core::result"},{"anchor":"function-is_err","name":"is_err","type":"fn is_err<T, U>(res: & Result<T, U>) -> bool","self":"","desc":"Returns true if the result is ","path":"core::result"},{"anchor":"function-is_ok","name":"is_ok","type":"fn is_ok<T, U>(res: & Result<T, U>) -> bool","self":"","desc":"Returns true if the result is ","path":"core::result"},{"anchor":"function-iter","name":"iter","type":"fn iter<T, E>(res: & Result<T, E>, f: fn&(& T))","self":"","desc":"Call a function based on a previous result","path":"core::result"},{"anchor":"function-iter_err","name":"iter_err","type":"fn iter_err<T, E>(res: & Result<T, E>, f: fn&(& E))","self":"","desc":"Call a function based on a previous result","path":"core::result"},{"anchor":"function-iter_vec2","name":"iter_vec2","type":"fn iter_vec2<S, T,\n             U: Copy>(ss: & [S], ts: & [T],\n                      op: fn&(& S, & T) -> Result<(), U>) -> Result<(), U>","self":"","desc":"Applies op to the pairwise elements from ","path":"core::result"},{"anchor":"function-map","name":"map","type":"fn map<T, E: Copy, U: Copy>(res: & Result<T, E>, op: fn&(& T) -> U) ->\n   Result<U, E>","self":"","desc":"Call a function based on a previous result","path":"core::result"},{"anchor":"function-map_err","name":"map_err","type":"fn map_err<T: Copy, E, F: Copy>(res: & Result<T, E>, op: fn&(& E) -> F) ->\n   Result<T, F>","self":"","desc":"Call a function based on a previous result","path":"core::result"},{"anchor":"function-map_opt","name":"map_opt","type":"fn map_opt<T, U: Copy,\n           V: Copy>(o_t: & Option<T>, op: fn&(& T) -> Result<V, U>) ->\n   Result<Option<V>, U>","self":"","desc":"","path":"core::result"},{"anchor":"function-map_vec","name":"map_vec","type":"fn map_vec<T, U: Copy, V: Copy>(ts: & [T], op: fn&(& T) -> Result<V, U>) ->\n   Result<~[V], U>","self":"","desc":"Maps each element in the vector ","path":"core::result"},{"anchor":"function-map_vec2","name":"map_vec2","type":"fn map_vec2<S, T, U: Copy,\n            V: Copy>(ss: & [S], ts: & [T], op: fn&(& S, & T) -> Result<V, U>)\n   -> Result<~[V], U>","self":"","desc":"Same as map, but it operates over two parallel vectors.","path":"core::result"},{"anchor":"function-to_either","name":"to_either","type":"fn to_either<T: Copy, U: Copy>(res: & Result<U, T>) -> Either<T, U>","self":"","desc":"Convert to the ","path":"core::result"},{"anchor":"function-unwrap","name":"unwrap","type":"fn unwrap<T, U>(res: Result<T, U>) -> T","self":"","desc":"Unwraps a result, assuming it is an ","path":"core::result"},{"anchor":"function-unwrap_err","name":"unwrap_err","type":"fn unwrap_err<T, U>(res: Result<T, U>) -> U","self":"","desc":"Unwraps a result, assuming it is an ","path":"core::result"},{"anchor":"function-get_type_desc","name":"get_type_desc","type":"fn get_type_desc<T>() -> *TypeDesc","self":"","desc":"Returns a pointer to a type descriptor.","path":"core::sys"},{"anchor":"function-log_str","name":"log_str","type":"fn log_str<T>(t: & T) -> ~str","self":"","desc":"","path":"core::sys"},{"anchor":"function-min_align_of","name":"min_align_of","type":"fn min_align_of<T>() -> uint","self":"","desc":"Returns the ABI-required minimum alignment of a type","path":"core::sys"},{"anchor":"function-pref_align_of","name":"pref_align_of","type":"fn pref_align_of<T>() -> uint","self":"","desc":"Returns the preferred alignment of a type","path":"core::sys"},{"anchor":"function-refcount","name":"refcount","type":"fn refcount<T>(t: @T) -> uint","self":"","desc":"Returns the refcount of a shared box (as just before calling this)","path":"core::sys"},{"anchor":"function-shape_eq","name":"shape_eq","type":"fn shape_eq<T: Eq>(x1: & T, x2: & T) -> bool","self":"","desc":"Compares contents of two pointers using the default method.","path":"core::sys"},{"anchor":"function-shape_le","name":"shape_le","type":"fn shape_le<T: Ord>(x1: & T, x2: & T) -> bool","self":"","desc":"","path":"core::sys"},{"anchor":"function-shape_lt","name":"shape_lt","type":"fn shape_lt<T: Ord>(x1: & T, x2: & T) -> bool","self":"","desc":"","path":"core::sys"},{"anchor":"function-size_of","name":"size_of","type":"fn size_of<T>() -> uint","self":"","desc":"Returns the size of a type","path":"core::sys"},{"anchor":"method-unlinked","name":"unlinked","type":"fn unlinked() -> TaskBuilder","self":"TaskBuilder","desc":"a method of TaskBuilder: Decouple the child task's failure from the parent's. If either fails, the other will not be killed.","path":"core::task"},{"anchor":"method-supervised","name":"supervised","type":"fn supervised() -> TaskBuilder","self":"TaskBuilder","desc":"a method of TaskBuilder: Unidirectionally link the child task's failure with the parent's. The child's failure will not kill the parent, but the parent's will kill the child.","path":"core::task"},{"anchor":"method-linked","name":"linked","type":"fn linked() -> TaskBuilder","self":"TaskBuilder","desc":"a method of TaskBuilder: Link the child task's and parent task's failures. If either fails, the other will be killed.","path":"core::task"},{"anchor":"method-future_result","name":"future_result","type":"fn future_result(blk: fn&(v: future::Future<TaskResult>)) -> TaskBuilder","self":"TaskBuilder","desc":"a method of TaskBuilder: Get a future representing the exit status of the task.","path":"core::task"},{"anchor":"method-sched_mode","name":"sched_mode","type":"fn sched_mode(mode: SchedMode) -> TaskBuilder","self":"TaskBuilder","desc":"a method of TaskBuilder: Configure a custom scheduler mode for the task.","path":"core::task"},{"anchor":"method-add_wrapper","name":"add_wrapper","type":"fn add_wrapper(wrapper: fn@(v: fn~()) -> fn~()) -> TaskBuilder","self":"TaskBuilder","desc":"a method of TaskBuilder: Add a wrapper to the body of the spawned task.","path":"core::task"},{"anchor":"method-spawn","name":"spawn","type":"fn spawn(f: fn~())","self":"TaskBuilder","desc":"a method of TaskBuilder: Creates and executes a new child task","path":"core::task"},{"anchor":"method-spawn_with","name":"spawn_with","type":"fn spawn_with<A: Send>(arg: A, f: fn~(v: A))","self":"TaskBuilder","desc":"a method of TaskBuilder: Runs a task, while transfering ownership of one argument to the child.","path":"core::task"},{"anchor":"method-spawn_listener","name":"spawn_listener","type":"fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A>","self":"TaskBuilder","desc":"a method of TaskBuilder: Runs a new task while providing a channel from the parent to the child","path":"core::task"},{"anchor":"method-spawn_conversation","name":"spawn_conversation","type":"fn spawn_conversation<A: Send, B: Send>(f: fn~(comm::Port<A>, comm::Chan<B>))\n   -> (comm::Port<B>, comm::Chan<A>)","self":"TaskBuilder","desc":"a method of TaskBuilder: Runs a new task, setting up communication in both directions","path":"core::task"},{"anchor":"method-try","name":"try","type":"fn try<T: Send>(f: fn~() -> T) -> Result<T, ()>","self":"TaskBuilder","desc":"a method of TaskBuilder: Execute a function in another task and return either the return value of the function or result::err.","path":"core::task"},{"anchor":"function-atomically","name":"atomically","type":"fn atomically<U>(f: fn&() -> U) -> U","self":"","desc":"A stronger version of unkillable that also inhibits scheduling operations. For use with exclusive ARCs, which use pthread mutexes directly.","path":"core::task"},{"anchor":"function-default_task_opts","name":"default_task_opts","type":"fn default_task_opts() -> TaskOpts","self":"","desc":"The default task options","path":"core::task"},{"anchor":"function-failing","name":"failing","type":"fn failing() -> bool","self":"","desc":"True if the running task has failed","path":"core::task"},{"anchor":"function-get_task","name":"get_task","type":"fn get_task() -> Task","self":"","desc":"Get a handle to the running task","path":"core::task"},{"anchor":"function-rekillable","name":"rekillable","type":"fn rekillable<U>(f: fn&() -> U) -> U","self":"","desc":"The inverse of unkillable. Only ever to be used nested in unkillable().","path":"core::task"},{"anchor":"function-spawn","name":"spawn","type":"fn spawn(f: fn~())","self":"","desc":"Creates and executes a new child task","path":"core::task"},{"anchor":"function-spawn_conversation","name":"spawn_conversation","type":"fn spawn_conversation<A: Send, B: Send>(f: fn~(comm::Port<A>, comm::Chan<B>))\n   -> (comm::Port<B>, comm::Chan<A>)","self":"","desc":"Runs a new task, setting up communication in both directions","path":"core::task"},{"anchor":"function-spawn_listener","name":"spawn_listener","type":"fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A>","self":"","desc":"Runs a new task while providing a channel from the parent to the child","path":"core::task"},{"anchor":"function-spawn_sched","name":"spawn_sched","type":"fn spawn_sched(mode: SchedMode, f: fn~())","self":"","desc":"Creates a new scheduler and executes a task on it","path":"core::task"},{"anchor":"function-spawn_supervised","name":"spawn_supervised","type":"fn spawn_supervised(f: fn~())","self":"","desc":"Creates a child task unlinked from the current one. If either this task or the child task fails, the other will not be killed.","path":"core::task"},{"anchor":"function-spawn_unlinked","name":"spawn_unlinked","type":"fn spawn_unlinked(f: fn~())","self":"","desc":"Creates a child task unlinked from the current one. If either this task or the child task fails, the other will not be killed.","path":"core::task"},{"anchor":"function-spawn_with","name":"spawn_with","type":"fn spawn_with<A: Send>(arg: A, f: fn~(v: A))","self":"","desc":"Runs a task, while transfering ownership of one argument to the child.","path":"core::task"},{"anchor":"function-task","name":"task","type":"fn task() -> TaskBuilder","self":"","desc":"Generate the base configuration for spawning a task, off of which more configuration methods can be chained. For example, task().unlinked().spawn is equivalent to spawn_unlinked.","path":"core::task"},{"anchor":"function-try","name":"try","type":"fn try<T: Send>(f: fn~() -> T) -> Result<T, ()>","self":"","desc":"Execute a function in another task and return either the return value of the function or result::err.","path":"core::task"},{"anchor":"function-unkillable","name":"unkillable","type":"fn unkillable<U>(f: fn&() -> U) -> U","self":"","desc":"Temporarily make the task unkillable","path":"core::task"},{"anchor":"function-yield","name":"yield","type":"fn yield()","self":"","desc":"Yield control to the task scheduler","path":"core::task"},{"anchor":"function-borrow","name":"borrow","type":"fn borrow<A>(a: &x/[A]) -> &x/[A]","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-iter_bytes_2","name":"iter_bytes_2","type":"fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: & A, b: & B, lsb0: bool, z: Cb)","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-iter_bytes_3","name":"iter_bytes_3","type":"fn iter_bytes_3<A: IterBytes, B: IterBytes,\n                C: IterBytes>(a: & A, b: & B, c: & C, lsb0: bool, z: Cb)","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-iter_bytes_4","name":"iter_bytes_4","type":"fn iter_bytes_4<A: IterBytes, B: IterBytes, C: IterBytes,\n                D: IterBytes>(a: & A, b: & B, c: & C, d: & D, lsb0: bool,\n                              z: Cb)","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-iter_bytes_5","name":"iter_bytes_5","type":"fn iter_bytes_5<A: IterBytes, B: IterBytes, C: IterBytes, D: IterBytes,\n                E: IterBytes>(a: & A, b: & B, c: & C, d: & D, e: & E,\n                              lsb0: bool, z: Cb)","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-iter_bytes_6","name":"iter_bytes_6","type":"fn iter_bytes_6<A: IterBytes, B: IterBytes, C: IterBytes, D: IterBytes,\n                E: IterBytes,\n                F: IterBytes>(a: & A, b: & B, c: & C, d: & D, e: & E, f: & F,\n                              lsb0: bool, z: Cb)","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-iter_bytes_7","name":"iter_bytes_7","type":"fn iter_bytes_7<A: IterBytes, B: IterBytes, C: IterBytes, D: IterBytes,\n                E: IterBytes, F: IterBytes,\n                G: IterBytes>(a: & A, b: & B, c: & C, d: & D, e: & E, f: & F,\n                              g: & G, lsb0: bool, z: Cb)","self":"","desc":"","path":"core::to_bytes"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::u16"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::u16"},{"anchor":"function-from_str_radix","name":"from_str_radix","type":"fn from_str_radix(buf: & str, radix: u64) -> Option<u64>","self":"","desc":"Parse a string as an unsigned integer.","path":"core::u16"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::u16"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [const u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::u16"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::u16"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::u16"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::u16"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(num: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::u16"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(neg: bool, num: T, radix: uint, f: fn&(v: & [u8]) -> U) ->\n   U","self":"","desc":"Low-level helper routine for string conversion.","path":"core::u16"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::u32"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::u32"},{"anchor":"function-from_str_radix","name":"from_str_radix","type":"fn from_str_radix(buf: & str, radix: u64) -> Option<u64>","self":"","desc":"Parse a string as an unsigned integer.","path":"core::u32"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::u32"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [const u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::u32"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::u32"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::u32"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::u32"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(num: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::u32"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(neg: bool, num: T, radix: uint, f: fn&(v: & [u8]) -> U) ->\n   U","self":"","desc":"Low-level helper routine for string conversion.","path":"core::u32"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::u64"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::u64"},{"anchor":"function-from_str_radix","name":"from_str_radix","type":"fn from_str_radix(buf: & str, radix: u64) -> Option<u64>","self":"","desc":"Parse a string as an unsigned integer.","path":"core::u64"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::u64"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [const u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::u64"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::u64"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::u64"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::u64"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(num: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::u64"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(neg: bool, num: T, radix: uint, f: fn&(v: & [u8]) -> U) ->\n   U","self":"","desc":"Low-level helper routine for string conversion.","path":"core::u64"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::u8"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::u8"},{"anchor":"function-from_str_radix","name":"from_str_radix","type":"fn from_str_radix(buf: & str, radix: u64) -> Option<u64>","self":"","desc":"Parse a string as an unsigned integer.","path":"core::u8"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::u8"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [const u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::u8"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::u8"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::u8"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::u8"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(num: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::u8"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(neg: bool, num: T, radix: uint, f: fn&(v: & [u8]) -> U) ->\n   U","self":"","desc":"Low-level helper routine for string conversion.","path":"core::u8"},{"anchor":"function-add","name":"add","type":"fn add(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-compl","name":"compl","type":"fn compl(i: T) -> T","self":"","desc":"Computes the bitwise complement","path":"core::uint"},{"anchor":"function-div","name":"div","type":"fn div(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-eq","name":"eq","type":"fn eq(x: T, y: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-from_str","name":"from_str","type":"fn from_str(s: & str) -> Option<T>","self":"","desc":"Parse a string to an int","path":"core::uint"},{"anchor":"function-from_str_radix","name":"from_str_radix","type":"fn from_str_radix(buf: & str, radix: u64) -> Option<u64>","self":"","desc":"Parse a string as an unsigned integer.","path":"core::uint"},{"anchor":"function-ge","name":"ge","type":"fn ge(x: T, y: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-gt","name":"gt","type":"fn gt(x: T, y: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-is_negative","name":"is_negative","type":"fn is_negative(x: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-is_nonnegative","name":"is_nonnegative","type":"fn is_nonnegative(x: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-is_nonpositive","name":"is_nonpositive","type":"fn is_nonpositive(x: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-is_positive","name":"is_positive","type":"fn is_positive(x: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-le","name":"le","type":"fn le(x: T, y: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-lt","name":"lt","type":"fn lt(x: T, y: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-max","name":"max","type":"fn max(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-min","name":"min","type":"fn min(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-mul","name":"mul","type":"fn mul(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-ne","name":"ne","type":"fn ne(x: T, y: T) -> bool","self":"","desc":"","path":"core::uint"},{"anchor":"function-parse_bytes","name":"parse_bytes","type":"fn parse_bytes(buf: & [const u8], radix: uint) -> Option<T>","self":"","desc":"Parse a buffer of bytes","path":"core::uint"},{"anchor":"function-range","name":"range","type":"fn range(lo: T, hi: T, it: fn&(T) -> bool)","self":"","desc":"Iterate over the range [","path":"core::uint"},{"anchor":"function-rem","name":"rem","type":"fn rem(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-str","name":"str","type":"fn str(i: T) -> ~str","self":"","desc":"Convert to a string","path":"core::uint"},{"anchor":"function-sub","name":"sub","type":"fn sub(x: T, y: T) -> T","self":"","desc":"","path":"core::uint"},{"anchor":"function-to_str","name":"to_str","type":"fn to_str(num: T, radix: uint) -> ~str","self":"","desc":"Convert to a string in a given base","path":"core::uint"},{"anchor":"function-to_str_bytes","name":"to_str_bytes","type":"fn to_str_bytes<U>(neg: bool, num: T, radix: uint, f: fn&(v: & [u8]) -> U) ->\n   U","self":"","desc":"Low-level helper routine for string conversion.","path":"core::uint"},{"anchor":"function-noncopyable","name":"NonCopyable","type":"fn NonCopyable() -> NonCopyable","self":"","desc":"","path":"core::util"},{"anchor":"function-id","name":"id","type":"fn id<T>(x: T) -> T","self":"","desc":"The identity function.","path":"core::util"},{"anchor":"function-ignore","name":"ignore","type":"fn ignore<T>(_x: T)","self":"","desc":"Ignores a value.","path":"core::util"},{"anchor":"function-replace","name":"replace","type":"fn replace<T>(dest: & mut T, src: T) -> T","self":"","desc":"Replace the value at a mutable location with a new one, returning the old value, without deinitialising or copying either one.","path":"core::util"},{"anchor":"function-swap","name":"swap","type":"fn swap<T>(x: & mut T, y: & mut T)","self":"","desc":"Swap the values at two mutable locations of the same type, without deinitialising or copying either one.","path":"core::util"},{"anchor":"function-unreachable","name":"unreachable","type":"fn unreachable() -> !","self":"","desc":"A utility function for indicating unreachable code. It will fail if executed. This is occasionally useful to put after loops that never terminate normally, but instead directly return from a function.","path":"core::util"},{"anchor":"function-with","name":"with","type":"fn with<T: Copy, R>(ptr: & mut T, new_value: T, op: & fn&() -> R) -> R","self":"","desc":"Sets ","path":"core::util"}]